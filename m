Return-Path: <linux-kernel+bounces-640845-lists+linux-kernel=lfdr.de@vger.kernel.org>
X-Original-To: lists+linux-kernel@lfdr.de
Delivered-To: lists+linux-kernel@lfdr.de
Received: from sy.mirrors.kernel.org (sy.mirrors.kernel.org [147.75.48.161])
	by mail.lfdr.de (Postfix) with ESMTPS id 3B3C3AB0A0A
	for <lists+linux-kernel@lfdr.de>; Fri,  9 May 2025 07:54:54 +0200 (CEST)
Received: from smtp.subspace.kernel.org (relay.kernel.org [52.25.139.140])
	(using TLSv1.2 with cipher ECDHE-ECDSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by sy.mirrors.kernel.org (Postfix) with ESMTPS id C62A3B215B1
	for <lists+linux-kernel@lfdr.de>; Fri,  9 May 2025 05:52:06 +0000 (UTC)
Received: from localhost.localdomain (localhost.localdomain [127.0.0.1])
	by smtp.subspace.kernel.org (Postfix) with ESMTP id 3C03026A091;
	Fri,  9 May 2025 05:52:43 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (1024-bit key) header.d=163.com header.i=@163.com header.b="Nb5qrDWs"
Received: from m16.mail.163.com (m16.mail.163.com [117.135.210.5])
	by smtp.subspace.kernel.org (Postfix) with ESMTP id 3FB2F26988A
	for <linux-kernel@vger.kernel.org>; Fri,  9 May 2025 05:52:36 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=117.135.210.5
ARC-Seal:i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1746769962; cv=none; b=oaBcWrJQnrh4Glf6UVw4PoD0+bQtZ/kk5Ko3mx/QZtV3hcSyUGBrKe8E+mRVV7VL9FfFB03meocgHUDuj+UwMaHvcIGE7d5aMacvz9xY3ENcTlnxLpKNexvrNJf0D1G7U5wFuobpH1YNobFpwA9W6EvDNqKWjo3B0HGC9frl0J0=
ARC-Message-Signature:i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1746769962; c=relaxed/simple;
	bh=mVTL1/7u0Zm3PURaDilOURE3iDAITYavMs3tfdNiglQ=;
	h=From:To:Cc:Subject:Date:Message-Id:In-Reply-To:References:
	 MIME-Version; b=sepOcVhomJB+dxaX5F0wrKgEu3jGf0sF0dILlpxgshvX4f5QgcdmwuqEZsIM5euTyeYloWt4barITmiv7QGm8ngMEyNTwqmGhI5hOa1KejLh6oqyEn3betW6A5vAqhQ+/eCER27Dkc12BYEniCo81qnmBM/+/wYhE/f+hiGcVaY=
ARC-Authentication-Results:i=1; smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=163.com; spf=pass smtp.mailfrom=163.com; dkim=pass (1024-bit key) header.d=163.com header.i=@163.com header.b=Nb5qrDWs; arc=none smtp.client-ip=117.135.210.5
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=163.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=163.com
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=163.com;
	s=s110527; h=From:To:Subject:Date:Message-Id:MIME-Version; bh=d6
	WxkoZbcjVZyf9EACzSEkRxB1GVijAxsQD+kDeVkBE=; b=Nb5qrDWsLUNsRMTzkh
	W6kAwhiz6PjjKu6782s2amkuqHfTTpC9JpsmK9AjO4fGBCNb8PfGuIXrqKYE1GVc
	aMd5dmiuRrYZKXCpXeWaMjz1cv4vzyRH3I1fE4NnfR/42VIUUW0LVe1+/a0I4hE1
	VX5zXlTNm0ozTrmPvQG8nc96k=
Received: from localhost.localdomain (unknown [])
	by gzga-smtp-mtada-g0-4 (Coremail) with SMTP id _____wD3Nwr4lx1oJRmWAA--.13467S4;
	Fri, 09 May 2025 13:52:08 +0800 (CST)
From: David Wang <00107082@163.com>
To: surenb@google.com,
	kent.overstreet@linux.dev,
	akpm@linux-foundation.org
Cc: linux-kernel@vger.kernel.org,
	David Wang <00107082@163.com>
Subject: [PATCH 1/2] alloc_tag: add timestamp to codetag iterator
Date: Fri,  9 May 2025 13:51:51 +0800
Message-Id: <20250509055151.922612-1-00107082@163.com>
X-Mailer: git-send-email 2.39.2
In-Reply-To: <20250507175500.204569-1-00107082@163.com>
References: <20250507175500.204569-1-00107082@163.com>
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
X-CM-TRANSID:_____wD3Nwr4lx1oJRmWAA--.13467S4
X-Coremail-Antispam: 1Uf129KBjvJXoW7tw1UWry5tr17Jw48Ww45Jrb_yoW5JFy8p3
	Wv9a45Kr48Ar47uFWxua1DZrn0gry7Kr47XFy2kw1akas8JF4xuF1UGw1akryrZFWvqrZ7
	KF1vqw18CF9FqFJanT9S1TB71UUUUU7qnTZGkaVYY2UrUUUUjbIjqfuFe4nvWSU5nxnvy2
	9KBjDUYxBIdaVFxhVjvjDU0xZFpf9x0pE8nYUUUUUU=
X-CM-SenderInfo: qqqrilqqysqiywtou0bp/xtbBkApIqmgdj4-6kQAAsm

Codetag iterator use <id,address> pair to guarantee the
validness. But both id and address can be reused, there is
theoretical possibility when module inserted right after
another module removed, kmalloc return an address kfree by
previous module and IDR key reuse the key recently removed.

Add timestamp to codetag_module and code_iterator, the
timestamp is generated by a clock which is strickly
incremented whenever a module is loaded. An iterator is
valid if and only if its timestamp match codetag_module's.

Signed-off-by: David Wang <00107082@163.com>
---
 include/linux/codetag.h |  1 +
 lib/codetag.c           | 12 ++++++++++--
 2 files changed, 11 insertions(+), 2 deletions(-)

diff --git a/include/linux/codetag.h b/include/linux/codetag.h
index d14dbd26b370..61d43c3fbd19 100644
--- a/include/linux/codetag.h
+++ b/include/linux/codetag.h
@@ -54,6 +54,7 @@ struct codetag_iterator {
 	struct codetag_module *cmod;
 	unsigned long mod_id;
 	struct codetag *ct;
+	unsigned long timestamp;
 };
 
 #ifdef MODULE
diff --git a/lib/codetag.c b/lib/codetag.c
index 42aadd6c1454..973bfa5dd5db 100644
--- a/lib/codetag.c
+++ b/lib/codetag.c
@@ -13,6 +13,8 @@ struct codetag_type {
 	struct idr mod_idr;
 	struct rw_semaphore mod_lock; /* protects mod_idr */
 	struct codetag_type_desc desc;
+	/* generates timestamp for module load */
+	unsigned long clock;
 };
 
 struct codetag_range {
@@ -23,6 +25,7 @@ struct codetag_range {
 struct codetag_module {
 	struct module *mod;
 	struct codetag_range range;
+	unsigned long timestamp;
 };
 
 static DEFINE_MUTEX(codetag_lock);
@@ -48,6 +51,7 @@ struct codetag_iterator codetag_get_ct_iter(struct codetag_type *cttype)
 		.cmod = NULL,
 		.mod_id = 0,
 		.ct = NULL,
+		.timestamp = 0,
 	};
 
 	return iter;
@@ -91,11 +95,13 @@ struct codetag *codetag_next_ct(struct codetag_iterator *iter)
 		if (!cmod)
 			break;
 
-		if (cmod != iter->cmod) {
+		if (!iter->cmod || iter->timestamp != cmod->timestamp) {
 			iter->cmod = cmod;
+			iter->timestamp = cmod->timestamp;
 			ct = get_first_module_ct(cmod);
-		} else
+		} else {
 			ct = get_next_module_ct(iter);
+		}
 
 		if (ct)
 			break;
@@ -190,6 +196,8 @@ static int codetag_module_init(struct codetag_type *cttype, struct module *mod)
 	cmod->range = range;
 
 	down_write(&cttype->mod_lock);
+	cttype->clock++;
+	cmod->timestamp = cttype->clock;
 	err = idr_alloc(&cttype->mod_idr, cmod, 0, 0, GFP_KERNEL);
 	if (err >= 0) {
 		cttype->count += range_size(cttype, &range);
-- 
2.39.2


