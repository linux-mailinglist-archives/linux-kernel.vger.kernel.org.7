Return-Path: <linux-kernel+bounces-804570-lists+linux-kernel=lfdr.de@vger.kernel.org>
X-Original-To: lists+linux-kernel@lfdr.de
Delivered-To: lists+linux-kernel@lfdr.de
Received: from am.mirrors.kernel.org (am.mirrors.kernel.org [IPv6:2604:1380:4601:e00::3])
	by mail.lfdr.de (Postfix) with ESMTPS id E26CBB479EA
	for <lists+linux-kernel@lfdr.de>; Sun,  7 Sep 2025 10:58:58 +0200 (CEST)
Received: from smtp.subspace.kernel.org (relay.kernel.org [52.25.139.140])
	(using TLSv1.2 with cipher ECDHE-ECDSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by am.mirrors.kernel.org (Postfix) with ESMTPS id AE577189F753
	for <lists+linux-kernel@lfdr.de>; Sun,  7 Sep 2025 08:59:18 +0000 (UTC)
Received: from localhost.localdomain (localhost.localdomain [127.0.0.1])
	by smtp.subspace.kernel.org (Postfix) with ESMTP id 46DE5220F5D;
	Sun,  7 Sep 2025 08:58:38 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (1024-bit key) header.d=ideasonboard.com header.i=@ideasonboard.com header.b="RGcIEJN4"
Received: from perceval.ideasonboard.com (perceval.ideasonboard.com [213.167.242.64])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 9160D220F36
	for <linux-kernel@vger.kernel.org>; Sun,  7 Sep 2025 08:58:26 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=213.167.242.64
ARC-Seal:i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1757235512; cv=none; b=k4Mrdc8N/pcihVXuJ0HiXBOFxJYLL00vOso0+1VuaTliB+LUmyxr0YdZ2eIPNLx/8Yrzao2GnDvm6/LQXSc5t+xPPkWMclCERX8/SxkQG9NK00JtqrLFLU1/uo6YmN4/cYVvIpPo4i5fGHum1dVUbohnYiphA9BXZfBfzqY9hIg=
ARC-Message-Signature:i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1757235512; c=relaxed/simple;
	bh=SluR7o3CJF+XwhyIHmFTXWQZCt6Ms7i6S+i1/ntSIrQ=;
	h=From:Date:Subject:MIME-Version:Content-Type:Message-Id:References:
	 In-Reply-To:To:Cc; b=OboyZ2ahmdYnp81+ZUPVAMaOSAoFwzEQoJYekXaFXmASU4Oz3KR48LEy3MGO9+hsCj5gf0mRsev1RvaYwFEIfYOG0xg2ZRsl5mZQ26X6BXjl6oeAywoBp2xMjGiaQJ7mWtIViuy3f/K9TGeOy7lEwD/XmmglbRtwdMyIKso7M+4=
ARC-Authentication-Results:i=1; smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=ideasonboard.com; spf=pass smtp.mailfrom=ideasonboard.com; dkim=pass (1024-bit key) header.d=ideasonboard.com header.i=@ideasonboard.com header.b=RGcIEJN4; arc=none smtp.client-ip=213.167.242.64
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=ideasonboard.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=ideasonboard.com
Received: from mail.ideasonboard.com (unknown [IPv6:2401:4900:1c67:84a2:d86d:fcf7:24b4:e467])
	by perceval.ideasonboard.com (Postfix) with ESMTPSA id 98617156F;
	Sun,  7 Sep 2025 10:57:12 +0200 (CEST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=ideasonboard.com;
	s=mail; t=1757235433;
	bh=SluR7o3CJF+XwhyIHmFTXWQZCt6Ms7i6S+i1/ntSIrQ=;
	h=From:Date:Subject:References:In-Reply-To:To:Cc:From;
	b=RGcIEJN4HkAmRgjy9cbyDPZmgKgIdEu08Gi6FMSD7PAVkfd3aaFOcktevv6BAAZXW
	 qM1Qf26XpLLD0FoJXNAi34OZRUDrEALH3yG8snOGxYk0k4nUMXkR107C8taBV983Wo
	 ZcgLxln0Ba99VQNhfmJ1GVFjN6q3N3nXsprKuG9w=
From: Jai Luthra <jai.luthra@ideasonboard.com>
Date: Sun, 07 Sep 2025 14:26:24 +0530
Subject: [PATCH v2 4/5] media: staging: Drop bcm2835-camera driver
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 8bit
Message-Id: <20250907-vchiq-destage-v2-4-6884505dca78@ideasonboard.com>
References: <20250907-vchiq-destage-v2-0-6884505dca78@ideasonboard.com>
In-Reply-To: <20250907-vchiq-destage-v2-0-6884505dca78@ideasonboard.com>
To: Florian Fainelli <florian.fainelli@broadcom.com>, 
 Broadcom internal kernel review list <bcm-kernel-feedback-list@broadcom.com>, 
 Greg Kroah-Hartman <gregkh@linuxfoundation.org>, 
 Ray Jui <rjui@broadcom.com>, Scott Branden <sbranden@broadcom.com>
Cc: linux-rpi-kernel@lists.infradead.org, 
 linux-arm-kernel@lists.infradead.org, linux-staging@lists.linux.dev, 
 linux-kernel@vger.kernel.org, kernel-list@raspberrypi.com, 
 Stefan Wahren <wahrenst@gmx.net>, 
 Dave Stevenson <dave.stevenson@raspberrypi.com>, 
 Laurent Pinchart <laurent.pinchart@ideasonboard.com>, 
 Jai Luthra <jai.luthra@ideasonboard.com>
X-Mailer: b4 0.14.2
X-Developer-Signature: v=1; a=openpgp-sha256; l=111055;
 i=jai.luthra@ideasonboard.com; h=from:subject:message-id;
 bh=SluR7o3CJF+XwhyIHmFTXWQZCt6Ms7i6S+i1/ntSIrQ=;
 b=owEBbQKS/ZANAwAKAUPekfkkmnFFAcsmYgBovUkJbyUdOHqgCOwNTakkQDTYw0kqDfqvaNefm
 OJgcKgY2kiJAjMEAAEKAB0WIQRN4NgY5dV16NRar8VD3pH5JJpxRQUCaL1JCQAKCRBD3pH5JJpx
 ReErD/4nwbJenIKLeOpca/RRYRQJwtXmue1yXdrbxDKDIerPu8QFtVXRdXiXjphQKe3IiZEiJTw
 lq3zKvhUjwy/jDxhTj7smnltAx0AlTSfsQ9+Xvuj1cEyDcGt+qI5LuLPEbHExTL5R/GxemcYZRN
 /y7gm4YK7nKn/d2KK3dIvbpPVQGZrwZUXBmNJEdR9o7oTVO1dBLzCeozGDT0btAOpNvTBjl+1cv
 lFMSsFGrM5P0ZDEicDmTxua3Zi05iewGd+9x+N4muy8vT+25zjrGu/5NiqFkJzyAqVE2UbYqlNB
 iXiJJWGSAfKoWAj5twsbvDZnVrIuOaWLsamxnUIDIcHZEHBnV7T3LbLGhkNAqSjAC2EYs8z/M9C
 DGTv0ehjTl6j3Wky4eRomPFvZGy8Z0wmSERjYbYQdEwntMLqyn+trKUVh3wYP8CkkRxCEzKj8HD
 supTvzkogXXjXw7TD2FucuWYeuxbvLe8TmYFSBfxsm+TvQIJaBXm/a74SPA0/XSB7l5KVrn5d7W
 r/GPWb8/43WQun/dbWKIJMfwAnMF/q94cp22V62sdqxoZTf6hRK0EGqtpbdJaC3Xf5CfzGxy/bR
 WOxekKsf3YiUvTGLZGgz4d4gZVDFP3UL+RBuYv0L877oWB+q3sb8nd88zCGRRyKVL3w8nfNK1Eu
 vIQliHwJx94bU7w==
X-Developer-Key: i=jai.luthra@ideasonboard.com; a=openpgp;
 fpr=4DE0D818E5D575E8D45AAFC543DE91F9249A7145

The bcm2835-camera driver is replaced by the V4L2 bcm2835-unicam driver
that is already upstream. So drop it from staging.

This also simplifies destaging of VCHIQ MMAL, by reducing the users of
the MMAL API (this driver is one of them).

Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Signed-off-by: Jai Luthra <jai.luthra@ideasonboard.com>
---
 drivers/staging/vc04_services/Kconfig              |    2 -
 drivers/staging/vc04_services/Makefile             |    1 -
 .../staging/vc04_services/bcm2835-camera/Kconfig   |   13 -
 .../staging/vc04_services/bcm2835-camera/Makefile  |    6 -
 drivers/staging/vc04_services/bcm2835-camera/TODO  |   17 -
 .../vc04_services/bcm2835-camera/bcm2835-camera.c  | 2012 --------------------
 .../vc04_services/bcm2835-camera/bcm2835-camera.h  |  142 --
 .../vc04_services/bcm2835-camera/controls.c        | 1399 --------------
 8 files changed, 3592 deletions(-)

diff --git a/drivers/staging/vc04_services/Kconfig b/drivers/staging/vc04_services/Kconfig
index f599f36c54062416305f49a9bba076c3f91c06d3..b9e6f369f54c3af6225f181e08ac14e3de044062 100644
--- a/drivers/staging/vc04_services/Kconfig
+++ b/drivers/staging/vc04_services/Kconfig
@@ -3,8 +3,6 @@ if BCM_VIDEOCORE
 
 source "drivers/staging/vc04_services/bcm2835-audio/Kconfig"
 
-source "drivers/staging/vc04_services/bcm2835-camera/Kconfig"
-
 source "drivers/staging/vc04_services/vchiq-mmal/Kconfig"
 
 endif
diff --git a/drivers/staging/vc04_services/Makefile b/drivers/staging/vc04_services/Makefile
index 51c9466ec7a28141cf66508f602f43cd89ad408b..7a716a5c781530b673027b9f82ec94ebfd615f8a 100644
--- a/drivers/staging/vc04_services/Makefile
+++ b/drivers/staging/vc04_services/Makefile
@@ -1,5 +1,4 @@
 # SPDX-License-Identifier: GPL-2.0
 obj-$(CONFIG_SND_BCM2835)		+= bcm2835-audio/
-obj-$(CONFIG_VIDEO_BCM2835)		+= bcm2835-camera/
 obj-$(CONFIG_BCM2835_VCHIQ_MMAL)	+= vchiq-mmal/
 
diff --git a/drivers/staging/vc04_services/bcm2835-camera/Kconfig b/drivers/staging/vc04_services/bcm2835-camera/Kconfig
deleted file mode 100644
index 870c9afb223a220baf6238dc235a8b7634763831..0000000000000000000000000000000000000000
--- a/drivers/staging/vc04_services/bcm2835-camera/Kconfig
+++ /dev/null
@@ -1,13 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-config VIDEO_BCM2835
-	tristate "BCM2835 Camera"
-	depends on MEDIA_SUPPORT
-	depends on VIDEO_DEV && (ARCH_BCM2835 || COMPILE_TEST)
-	select BCM2835_VCHIQ if HAS_DMA
-	select BCM2835_VCHIQ_MMAL if HAS_DMA
-	select VIDEOBUF2_VMALLOC
-	select BTREE
-	help
-	  Say Y here to enable camera host interface devices for
-	  Broadcom BCM2835 SoC. This operates over the VCHIQ interface
-	  to a service running on VideoCore.
diff --git a/drivers/staging/vc04_services/bcm2835-camera/Makefile b/drivers/staging/vc04_services/bcm2835-camera/Makefile
deleted file mode 100644
index 203b93899b2065bfe9c1326f31ab01b66b829db2..0000000000000000000000000000000000000000
--- a/drivers/staging/vc04_services/bcm2835-camera/Makefile
+++ /dev/null
@@ -1,6 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-bcm2835-v4l2-$(CONFIG_VIDEO_BCM2835) := \
-	bcm2835-camera.o \
-	controls.o
-
-obj-$(CONFIG_VIDEO_BCM2835) += bcm2835-v4l2.o
diff --git a/drivers/staging/vc04_services/bcm2835-camera/TODO b/drivers/staging/vc04_services/bcm2835-camera/TODO
deleted file mode 100644
index 6c2b4ffe49964096e135fc400ab070672c18458a..0000000000000000000000000000000000000000
--- a/drivers/staging/vc04_services/bcm2835-camera/TODO
+++ /dev/null
@@ -1,17 +0,0 @@
-1) Support dma-buf memory management.
-
-In order to zero-copy import camera images into the 3D or display
-pipelines, we need to export our buffers through dma-buf so that the
-vc4 driver can import them.  This may involve bringing in the VCSM
-driver (which allows long-term management of regions of memory in the
-space that the VPU reserved and Linux otherwise doesn't have access
-to), or building some new protocol that allows VCSM-style management
-of Linux's CMA memory.
-
-2) Avoid extra copies for padding of images.
-
-We expose V4L2_PIX_FMT_* formats that have a specified stride/height
-padding in the V4L2 spec, but that padding doesn't match what the
-hardware can do.  If we exposed the native padding requirements
-through the V4L2 "multiplanar" formats, the firmware would have one
-less copy it needed to do.
diff --git a/drivers/staging/vc04_services/bcm2835-camera/bcm2835-camera.c b/drivers/staging/vc04_services/bcm2835-camera/bcm2835-camera.c
deleted file mode 100644
index d5e7b2d78eb478372e249ef0029874dffbc7e84f..0000000000000000000000000000000000000000
--- a/drivers/staging/vc04_services/bcm2835-camera/bcm2835-camera.c
+++ /dev/null
@@ -1,2012 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Broadcom BCM2835 V4L2 driver
- *
- * Copyright Â© 2013 Raspberry Pi (Trading) Ltd.
- *
- * Authors: Vincent Sanders @ Collabora
- *          Dave Stevenson @ Broadcom
- *		(now dave.stevenson@raspberrypi.org)
- *          Simon Mellor @ Broadcom
- *          Luke Diamand @ Broadcom
- */
-
-#include <linux/dma-mapping.h>
-#include <linux/errno.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/slab.h>
-#include <media/videobuf2-vmalloc.h>
-#include <media/videobuf2-dma-contig.h>
-#include <media/v4l2-device.h>
-#include <media/v4l2-ioctl.h>
-#include <media/v4l2-ctrls.h>
-#include <media/v4l2-fh.h>
-#include <media/v4l2-event.h>
-#include <media/v4l2-common.h>
-#include <linux/delay.h>
-
-#include <linux/raspberrypi/vchiq_bus.h>
-
-#include "../vchiq-mmal/mmal-common.h"
-#include "../vchiq-mmal/mmal-encodings.h"
-#include "../vchiq-mmal/mmal-vchiq.h"
-#include "../vchiq-mmal/mmal-msg.h"
-#include "../vchiq-mmal/mmal-parameters.h"
-#include "bcm2835-camera.h"
-
-#define MIN_WIDTH 32
-#define MIN_HEIGHT 32
-#define MIN_BUFFER_SIZE (80 * 1024)
-
-#define MAX_VIDEO_MODE_WIDTH 1280
-#define MAX_VIDEO_MODE_HEIGHT 720
-
-#define MAX_BCM2835_CAMERAS 2
-
-int bcm2835_v4l2_debug;
-module_param_named(debug, bcm2835_v4l2_debug, int, 0644);
-MODULE_PARM_DESC(bcm2835_v4l2_debug, "Debug level 0-2");
-
-#define UNSET (-1)
-static int video_nr[] = {[0 ... (MAX_BCM2835_CAMERAS - 1)] = UNSET };
-module_param_array(video_nr, int, NULL, 0644);
-MODULE_PARM_DESC(video_nr, "videoX start numbers, -1 is autodetect");
-
-static int max_video_width = MAX_VIDEO_MODE_WIDTH;
-static int max_video_height = MAX_VIDEO_MODE_HEIGHT;
-module_param(max_video_width, int, 0644);
-MODULE_PARM_DESC(max_video_width, "Threshold for video mode");
-module_param(max_video_height, int, 0644);
-MODULE_PARM_DESC(max_video_height, "Threshold for video mode");
-
-/* camera instance counter */
-static atomic_t camera_instance = ATOMIC_INIT(0);
-
-/* global device data array */
-static struct bcm2835_mmal_dev *gdev[MAX_BCM2835_CAMERAS];
-
-#define FPS_MIN 1
-#define FPS_MAX 90
-
-/* timeperframe: min/max and default */
-static const struct v4l2_fract
-	tpf_min     = {.numerator = 1,		.denominator = FPS_MAX},
-	tpf_max     = {.numerator = 1,	        .denominator = FPS_MIN},
-	tpf_default = {.numerator = 1000,	.denominator = 30000};
-
-/* Container for MMAL and VB2 buffers*/
-struct vb2_mmal_buffer {
-	struct vb2_v4l2_buffer	vb;
-	struct mmal_buffer	mmal;
-};
-
-/* video formats */
-static struct mmal_fmt formats[] = {
-	{
-		.fourcc = V4L2_PIX_FMT_YUV420,
-		.mmal = MMAL_ENCODING_I420,
-		.depth = 12,
-		.mmal_component = COMP_CAMERA,
-		.ybbp = 1,
-		.remove_padding = true,
-	}, {
-		.fourcc = V4L2_PIX_FMT_YUYV,
-		.mmal = MMAL_ENCODING_YUYV,
-		.depth = 16,
-		.mmal_component = COMP_CAMERA,
-		.ybbp = 2,
-		.remove_padding = false,
-	}, {
-		.fourcc = V4L2_PIX_FMT_RGB24,
-		.mmal = MMAL_ENCODING_RGB24,
-		.depth = 24,
-		.mmal_component = COMP_CAMERA,
-		.ybbp = 3,
-		.remove_padding = false,
-	}, {
-		.fourcc = V4L2_PIX_FMT_JPEG,
-		.flags = V4L2_FMT_FLAG_COMPRESSED,
-		.mmal = MMAL_ENCODING_JPEG,
-		.depth = 8,
-		.mmal_component = COMP_IMAGE_ENCODE,
-		.ybbp = 0,
-		.remove_padding = false,
-	}, {
-		.fourcc = V4L2_PIX_FMT_H264,
-		.flags = V4L2_FMT_FLAG_COMPRESSED,
-		.mmal = MMAL_ENCODING_H264,
-		.depth = 8,
-		.mmal_component = COMP_VIDEO_ENCODE,
-		.ybbp = 0,
-		.remove_padding = false,
-	}, {
-		.fourcc = V4L2_PIX_FMT_MJPEG,
-		.flags = V4L2_FMT_FLAG_COMPRESSED,
-		.mmal = MMAL_ENCODING_MJPEG,
-		.depth = 8,
-		.mmal_component = COMP_VIDEO_ENCODE,
-		.ybbp = 0,
-		.remove_padding = false,
-	}, {
-		.fourcc = V4L2_PIX_FMT_YVYU,
-		.mmal = MMAL_ENCODING_YVYU,
-		.depth = 16,
-		.mmal_component = COMP_CAMERA,
-		.ybbp = 2,
-		.remove_padding = false,
-	}, {
-		.fourcc = V4L2_PIX_FMT_VYUY,
-		.mmal = MMAL_ENCODING_VYUY,
-		.depth = 16,
-		.mmal_component = COMP_CAMERA,
-		.ybbp = 2,
-		.remove_padding = false,
-	}, {
-		.fourcc = V4L2_PIX_FMT_UYVY,
-		.mmal = MMAL_ENCODING_UYVY,
-		.depth = 16,
-		.mmal_component = COMP_CAMERA,
-		.ybbp = 2,
-		.remove_padding = false,
-	}, {
-		.fourcc = V4L2_PIX_FMT_NV12,
-		.mmal = MMAL_ENCODING_NV12,
-		.depth = 12,
-		.mmal_component = COMP_CAMERA,
-		.ybbp = 1,
-		.remove_padding = true,
-	}, {
-		.fourcc = V4L2_PIX_FMT_BGR24,
-		.mmal = MMAL_ENCODING_BGR24,
-		.depth = 24,
-		.mmal_component = COMP_CAMERA,
-		.ybbp = 3,
-		.remove_padding = false,
-	}, {
-		.fourcc = V4L2_PIX_FMT_YVU420,
-		.mmal = MMAL_ENCODING_YV12,
-		.depth = 12,
-		.mmal_component = COMP_CAMERA,
-		.ybbp = 1,
-		.remove_padding = true,
-	}, {
-		.fourcc = V4L2_PIX_FMT_NV21,
-		.mmal = MMAL_ENCODING_NV21,
-		.depth = 12,
-		.mmal_component = COMP_CAMERA,
-		.ybbp = 1,
-		.remove_padding = true,
-	}, {
-		.fourcc = V4L2_PIX_FMT_BGR32,
-		.mmal = MMAL_ENCODING_BGRA,
-		.depth = 32,
-		.mmal_component = COMP_CAMERA,
-		.ybbp = 4,
-		.remove_padding = false,
-	},
-};
-
-static struct mmal_fmt *get_format(struct v4l2_format *f)
-{
-	struct mmal_fmt *fmt;
-	unsigned int k;
-
-	for (k = 0; k < ARRAY_SIZE(formats); k++) {
-		fmt = &formats[k];
-		if (fmt->fourcc == f->fmt.pix.pixelformat)
-			return fmt;
-	}
-
-	return NULL;
-}
-
-/* ------------------------------------------------------------------
- *	Videobuf queue operations
- * ------------------------------------------------------------------
- */
-
-static int queue_setup(struct vb2_queue *vq,
-		       unsigned int *nbuffers, unsigned int *nplanes,
-		       unsigned int sizes[], struct device *alloc_ctxs[])
-{
-	struct bcm2835_mmal_dev *dev = vb2_get_drv_priv(vq);
-	unsigned long size;
-
-	/* refuse queue setup if port is not configured */
-	if (!dev->capture.port) {
-		v4l2_err(&dev->v4l2_dev,
-			 "%s: capture port not configured\n", __func__);
-		return -EINVAL;
-	}
-
-	/* Handle CREATE_BUFS situation - *nplanes != 0 */
-	if (*nplanes) {
-		if (*nplanes != 1 ||
-		    sizes[0] < dev->capture.port->current_buffer.size) {
-			v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-				 "%s: dev:%p Invalid buffer request from CREATE_BUFS, size %u < %u, nplanes %u != 1\n",
-				 __func__, dev, sizes[0],
-				 dev->capture.port->current_buffer.size,
-				 *nplanes);
-			return -EINVAL;
-		} else {
-			return 0;
-		}
-	}
-
-	/* Handle REQBUFS situation */
-	size = dev->capture.port->current_buffer.size;
-	if (size == 0) {
-		v4l2_err(&dev->v4l2_dev,
-			 "%s: capture port buffer size is zero\n", __func__);
-		return -EINVAL;
-	}
-
-	if (*nbuffers < dev->capture.port->minimum_buffer.num)
-		*nbuffers = dev->capture.port->minimum_buffer.num;
-
-	dev->capture.port->current_buffer.num = *nbuffers;
-
-	*nplanes = 1;
-
-	sizes[0] = size;
-
-	/*
-	 * videobuf2-vmalloc allocator is context-less so no need to set
-	 * alloc_ctxs array.
-	 */
-
-	v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev, "%s: dev:%p\n",
-		 __func__, dev);
-
-	return 0;
-}
-
-static int buffer_init(struct vb2_buffer *vb)
-{
-	struct bcm2835_mmal_dev *dev = vb2_get_drv_priv(vb->vb2_queue);
-	struct vb2_v4l2_buffer *vb2 = to_vb2_v4l2_buffer(vb);
-	struct vb2_mmal_buffer *buf =
-				container_of(vb2, struct vb2_mmal_buffer, vb);
-
-	v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev, "%s: dev:%p, vb %p\n",
-		 __func__, dev, vb);
-	buf->mmal.buffer = vb2_plane_vaddr(&buf->vb.vb2_buf, 0);
-	buf->mmal.buffer_size = vb2_plane_size(&buf->vb.vb2_buf, 0);
-
-	return mmal_vchi_buffer_init(dev->instance, &buf->mmal);
-}
-
-static int buffer_prepare(struct vb2_buffer *vb)
-{
-	struct bcm2835_mmal_dev *dev = vb2_get_drv_priv(vb->vb2_queue);
-	unsigned long size;
-
-	v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev, "%s: dev:%p, vb %p\n",
-		 __func__, dev, vb);
-
-	if (!dev->capture.port || !dev->capture.fmt)
-		return -ENODEV;
-
-	size = dev->capture.stride * dev->capture.height;
-	if (vb2_plane_size(vb, 0) < size) {
-		v4l2_err(&dev->v4l2_dev,
-			 "%s data will not fit into plane (%lu < %lu)\n",
-			 __func__, vb2_plane_size(vb, 0), size);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static void buffer_cleanup(struct vb2_buffer *vb)
-{
-	struct bcm2835_mmal_dev *dev = vb2_get_drv_priv(vb->vb2_queue);
-	struct vb2_v4l2_buffer *vb2 = to_vb2_v4l2_buffer(vb);
-	struct vb2_mmal_buffer *buf =
-				container_of(vb2, struct vb2_mmal_buffer, vb);
-
-	v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev, "%s: dev:%p, vb %p\n",
-		 __func__, dev, vb);
-
-	mmal_vchi_buffer_cleanup(&buf->mmal);
-}
-
-static inline bool is_capturing(struct bcm2835_mmal_dev *dev)
-{
-	return dev->capture.camera_port ==
-	    &dev->component[COMP_CAMERA]->output[CAM_PORT_CAPTURE];
-}
-
-static void buffer_cb(struct vchiq_mmal_instance *instance,
-		      struct vchiq_mmal_port *port,
-		      int status,
-		      struct mmal_buffer *mmal_buf)
-{
-	struct bcm2835_mmal_dev *dev = port->cb_ctx;
-	struct vb2_mmal_buffer *buf =
-			container_of(mmal_buf, struct vb2_mmal_buffer, mmal);
-
-	v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-		 "%s: status:%d, buf:%p, length:%lu, flags %u, pts %lld\n",
-		 __func__, status, buf, mmal_buf->length, mmal_buf->mmal_flags,
-		 mmal_buf->pts);
-
-	if (status) {
-		/* error in transfer */
-		if (buf) {
-			/* there was a buffer with the error so return it */
-			vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);
-		}
-		return;
-	}
-
-	if (mmal_buf->length == 0) {
-		/* stream ended */
-		if (dev->capture.frame_count) {
-			/* empty buffer whilst capturing - expected to be an
-			 * EOS, so grab another frame
-			 */
-			if (is_capturing(dev)) {
-				v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-					 "Grab another frame");
-				vchiq_mmal_port_parameter_set(instance,
-							      dev->capture.camera_port,
-							      MMAL_PARAMETER_CAPTURE,
-							      &dev->capture.frame_count,
-							      sizeof(dev->capture.frame_count));
-			}
-			if (vchiq_mmal_submit_buffer(instance, port,
-						     &buf->mmal))
-				v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-					 "Failed to return EOS buffer");
-		} else {
-			/* stopping streaming.
-			 * return buffer, and signal frame completion
-			 */
-			vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);
-			complete(&dev->capture.frame_cmplt);
-		}
-		return;
-	}
-
-	if (!dev->capture.frame_count) {
-		/* signal frame completion */
-		vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);
-		complete(&dev->capture.frame_cmplt);
-		return;
-	}
-
-	if (dev->capture.vc_start_timestamp != -1 && mmal_buf->pts) {
-		ktime_t timestamp;
-		s64 runtime_us = mmal_buf->pts -
-		    dev->capture.vc_start_timestamp;
-		timestamp = ktime_add_us(dev->capture.kernel_start_ts,
-					 runtime_us);
-		v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-			 "Convert start time %llu and %llu with offset %llu to %llu\n",
-			 ktime_to_ns(dev->capture.kernel_start_ts),
-			 dev->capture.vc_start_timestamp, mmal_buf->pts,
-			 ktime_to_ns(timestamp));
-		buf->vb.vb2_buf.timestamp = ktime_to_ns(timestamp);
-	} else {
-		buf->vb.vb2_buf.timestamp = ktime_get_ns();
-	}
-	buf->vb.sequence = dev->capture.sequence++;
-	buf->vb.field = V4L2_FIELD_NONE;
-
-	vb2_set_plane_payload(&buf->vb.vb2_buf, 0, mmal_buf->length);
-	if (mmal_buf->mmal_flags & MMAL_BUFFER_HEADER_FLAG_KEYFRAME)
-		buf->vb.flags |= V4L2_BUF_FLAG_KEYFRAME;
-
-	vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_DONE);
-
-	if (mmal_buf->mmal_flags & MMAL_BUFFER_HEADER_FLAG_EOS &&
-	    is_capturing(dev)) {
-		v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-			 "Grab another frame as buffer has EOS");
-		vchiq_mmal_port_parameter_set(instance,
-					      dev->capture.camera_port,
-					      MMAL_PARAMETER_CAPTURE,
-					      &dev->capture.frame_count,
-					      sizeof(dev->capture.frame_count));
-	}
-}
-
-static int enable_camera(struct bcm2835_mmal_dev *dev)
-{
-	int ret;
-
-	if (!dev->camera_use_count) {
-		ret = vchiq_mmal_port_parameter_set(dev->instance,
-						    &dev->component[COMP_CAMERA]->control,
-						    MMAL_PARAMETER_CAMERA_NUM, &dev->camera_num,
-						    sizeof(dev->camera_num));
-		if (ret < 0) {
-			v4l2_err(&dev->v4l2_dev,
-				 "Failed setting camera num, ret %d\n", ret);
-			return -EINVAL;
-		}
-
-		ret = vchiq_mmal_component_enable(dev->instance,
-						  dev->component[COMP_CAMERA]);
-		if (ret < 0) {
-			v4l2_err(&dev->v4l2_dev,
-				 "Failed enabling camera, ret %d\n", ret);
-			return -EINVAL;
-		}
-	}
-	dev->camera_use_count++;
-	v4l2_dbg(1, bcm2835_v4l2_debug,
-		 &dev->v4l2_dev, "enabled camera (refcount %d)\n",
-			dev->camera_use_count);
-	return 0;
-}
-
-static int disable_camera(struct bcm2835_mmal_dev *dev)
-{
-	int ret;
-
-	if (!dev->camera_use_count) {
-		v4l2_err(&dev->v4l2_dev,
-			 "Disabled the camera when already disabled\n");
-		return -EINVAL;
-	}
-	dev->camera_use_count--;
-	if (!dev->camera_use_count) {
-		unsigned int i = 0xFFFFFFFF;
-
-		v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-			 "Disabling camera\n");
-		ret = vchiq_mmal_component_disable(dev->instance,
-						   dev->component[COMP_CAMERA]);
-		if (ret < 0) {
-			v4l2_err(&dev->v4l2_dev,
-				 "Failed disabling camera, ret %d\n", ret);
-			return -EINVAL;
-		}
-		vchiq_mmal_port_parameter_set(dev->instance,
-					      &dev->component[COMP_CAMERA]->control,
-					      MMAL_PARAMETER_CAMERA_NUM,
-					      &i,
-					      sizeof(i));
-	}
-	v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-		 "Camera refcount now %d\n", dev->camera_use_count);
-	return 0;
-}
-
-static void buffer_queue(struct vb2_buffer *vb)
-{
-	struct bcm2835_mmal_dev *dev = vb2_get_drv_priv(vb->vb2_queue);
-	struct vb2_v4l2_buffer *vb2 = to_vb2_v4l2_buffer(vb);
-	struct vb2_mmal_buffer *buf =
-				container_of(vb2, struct vb2_mmal_buffer, vb);
-	int ret;
-
-	v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-		 "%s: dev:%p buf:%p, idx %u\n",
-		 __func__, dev, buf, vb2->vb2_buf.index);
-
-	ret = vchiq_mmal_submit_buffer(dev->instance, dev->capture.port,
-				       &buf->mmal);
-	if (ret < 0)
-		v4l2_err(&dev->v4l2_dev, "%s: error submitting buffer\n",
-			 __func__);
-}
-
-static int start_streaming(struct vb2_queue *vq, unsigned int count)
-{
-	struct bcm2835_mmal_dev *dev = vb2_get_drv_priv(vq);
-	int ret;
-	u32 parameter_size;
-
-	v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev, "%s: dev:%p\n",
-		 __func__, dev);
-
-	/* ensure a format has actually been set */
-	if (!dev->capture.port)
-		return -EINVAL;
-
-	if (enable_camera(dev) < 0) {
-		v4l2_err(&dev->v4l2_dev, "Failed to enable camera\n");
-		return -EINVAL;
-	}
-
-	/*init_completion(&dev->capture.frame_cmplt); */
-
-	/* enable frame capture */
-	dev->capture.frame_count = 1;
-
-	/* reset sequence number */
-	dev->capture.sequence = 0;
-
-	/* if the preview is not already running, wait for a few frames for AGC
-	 * to settle down.
-	 */
-	if (!dev->component[COMP_PREVIEW]->enabled)
-		msleep(300);
-
-	/* enable the connection from camera to encoder (if applicable) */
-	if (dev->capture.camera_port != dev->capture.port &&
-	    dev->capture.camera_port) {
-		ret = vchiq_mmal_port_enable(dev->instance,
-					     dev->capture.camera_port, NULL);
-		if (ret) {
-			v4l2_err(&dev->v4l2_dev,
-				 "Failed to enable encode tunnel - error %d\n",
-				 ret);
-			return -1;
-		}
-	}
-
-	/* Get VC timestamp at this point in time */
-	parameter_size = sizeof(dev->capture.vc_start_timestamp);
-	if (vchiq_mmal_port_parameter_get(dev->instance,
-					  dev->capture.camera_port,
-					  MMAL_PARAMETER_SYSTEM_TIME,
-					  &dev->capture.vc_start_timestamp,
-					  &parameter_size)) {
-		v4l2_err(&dev->v4l2_dev,
-			 "Failed to get VC start time - update your VC f/w\n");
-
-		/* Flag to indicate just to rely on kernel timestamps */
-		dev->capture.vc_start_timestamp = -1;
-	} else {
-		v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-			 "Start time %lld size %d\n",
-			 dev->capture.vc_start_timestamp, parameter_size);
-	}
-
-	dev->capture.kernel_start_ts = ktime_get();
-
-	/* enable the camera port */
-	dev->capture.port->cb_ctx = dev;
-	ret = vchiq_mmal_port_enable(dev->instance, dev->capture.port,
-				     buffer_cb);
-	if (ret) {
-		v4l2_err(&dev->v4l2_dev,
-			 "Failed to enable capture port - error %d. Disabling camera port again\n",
-			 ret);
-
-		vchiq_mmal_port_disable(dev->instance,
-					dev->capture.camera_port);
-		if (disable_camera(dev) < 0) {
-			v4l2_err(&dev->v4l2_dev, "Failed to disable camera\n");
-			return -EINVAL;
-		}
-		return -1;
-	}
-
-	/* capture the first frame */
-	vchiq_mmal_port_parameter_set(dev->instance,
-				      dev->capture.camera_port,
-				      MMAL_PARAMETER_CAPTURE,
-				      &dev->capture.frame_count,
-				      sizeof(dev->capture.frame_count));
-	return 0;
-}
-
-/* abort streaming and wait for last buffer */
-static void stop_streaming(struct vb2_queue *vq)
-{
-	int ret;
-	unsigned long time_left;
-	struct bcm2835_mmal_dev *dev = vb2_get_drv_priv(vq);
-	struct vchiq_mmal_port *port = dev->capture.port;
-
-	v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev, "%s: dev:%p\n",
-		 __func__, dev);
-
-	init_completion(&dev->capture.frame_cmplt);
-	dev->capture.frame_count = 0;
-
-	/* ensure a format has actually been set */
-	if (!port) {
-		v4l2_err(&dev->v4l2_dev,
-			 "no capture port - stream not started?\n");
-		return;
-	}
-
-	v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev, "stopping capturing\n");
-
-	/* stop capturing frames */
-	vchiq_mmal_port_parameter_set(dev->instance,
-				      dev->capture.camera_port,
-				      MMAL_PARAMETER_CAPTURE,
-				      &dev->capture.frame_count,
-				      sizeof(dev->capture.frame_count));
-
-	v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-		 "disabling connection\n");
-
-	/* disable the connection from camera to encoder */
-	ret = vchiq_mmal_port_disable(dev->instance, dev->capture.camera_port);
-	if (!ret && dev->capture.camera_port != port) {
-		v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-			 "disabling port\n");
-		ret = vchiq_mmal_port_disable(dev->instance, port);
-	} else if (dev->capture.camera_port != port) {
-		v4l2_err(&dev->v4l2_dev, "port_disable failed, error %d\n",
-			 ret);
-	}
-
-	/* wait for all buffers to be returned */
-	while (atomic_read(&port->buffers_with_vpu)) {
-		v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-			 "%s: Waiting for buffers to be returned - %d outstanding\n",
-			 __func__, atomic_read(&port->buffers_with_vpu));
-		time_left = wait_for_completion_timeout(&dev->capture.frame_cmplt,
-							HZ);
-		if (time_left == 0) {
-			v4l2_err(&dev->v4l2_dev, "%s: Timeout waiting for buffers to be returned - %d outstanding\n",
-				 __func__,
-				 atomic_read(&port->buffers_with_vpu));
-			break;
-		}
-	}
-
-	if (disable_camera(dev) < 0)
-		v4l2_err(&dev->v4l2_dev, "Failed to disable camera\n");
-}
-
-static const struct vb2_ops bcm2835_mmal_video_qops = {
-	.queue_setup = queue_setup,
-	.buf_init = buffer_init,
-	.buf_prepare = buffer_prepare,
-	.buf_cleanup = buffer_cleanup,
-	.buf_queue = buffer_queue,
-	.start_streaming = start_streaming,
-	.stop_streaming = stop_streaming,
-};
-
-/* ------------------------------------------------------------------
- *	IOCTL operations
- * ------------------------------------------------------------------
- */
-
-static int set_overlay_params(struct bcm2835_mmal_dev *dev,
-			      struct vchiq_mmal_port *port)
-{
-	struct mmal_parameter_displayregion prev_config = {
-		.set =	MMAL_DISPLAY_SET_LAYER |
-			MMAL_DISPLAY_SET_ALPHA |
-			MMAL_DISPLAY_SET_DEST_RECT |
-			MMAL_DISPLAY_SET_FULLSCREEN,
-		.layer = 2,
-		.alpha = dev->overlay.global_alpha,
-		.fullscreen = 0,
-		.dest_rect = {
-			.x = dev->overlay.w.left,
-			.y = dev->overlay.w.top,
-			.width = dev->overlay.w.width,
-			.height = dev->overlay.w.height,
-		},
-	};
-	return vchiq_mmal_port_parameter_set(dev->instance, port,
-					     MMAL_PARAMETER_DISPLAYREGION,
-					     &prev_config, sizeof(prev_config));
-}
-
-/* overlay ioctl */
-static int vidioc_enum_fmt_vid_overlay(struct file *file, void *priv,
-				       struct v4l2_fmtdesc *f)
-{
-	struct mmal_fmt *fmt;
-
-	if (f->index >= ARRAY_SIZE(formats))
-		return -EINVAL;
-
-	fmt = &formats[f->index];
-
-	f->pixelformat = fmt->fourcc;
-
-	return 0;
-}
-
-static int vidioc_g_fmt_vid_overlay(struct file *file, void *priv,
-				    struct v4l2_format *f)
-{
-	struct bcm2835_mmal_dev *dev = video_drvdata(file);
-
-	f->fmt.win = dev->overlay;
-
-	return 0;
-}
-
-static int vidioc_try_fmt_vid_overlay(struct file *file, void *priv,
-				      struct v4l2_format *f)
-{
-	struct bcm2835_mmal_dev *dev = video_drvdata(file);
-
-	f->fmt.win.field = V4L2_FIELD_NONE;
-	f->fmt.win.chromakey = 0;
-	f->fmt.win.clips = NULL;
-	f->fmt.win.clipcount = 0;
-	f->fmt.win.bitmap = NULL;
-
-	v4l_bound_align_image(&f->fmt.win.w.width, MIN_WIDTH, dev->max_width, 1,
-			      &f->fmt.win.w.height, MIN_HEIGHT, dev->max_height,
-			      1, 0);
-	v4l_bound_align_image(&f->fmt.win.w.left, MIN_WIDTH, dev->max_width, 1,
-			      &f->fmt.win.w.top, MIN_HEIGHT, dev->max_height,
-			      1, 0);
-
-	v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-		 "Overlay: Now w/h %dx%d l/t %dx%d\n",
-		f->fmt.win.w.width, f->fmt.win.w.height,
-		f->fmt.win.w.left, f->fmt.win.w.top);
-
-	v4l2_dump_win_format(1,
-			     bcm2835_v4l2_debug,
-			     &dev->v4l2_dev,
-			     &f->fmt.win,
-			     __func__);
-	return 0;
-}
-
-static int vidioc_s_fmt_vid_overlay(struct file *file, void *priv,
-				    struct v4l2_format *f)
-{
-	struct bcm2835_mmal_dev *dev = video_drvdata(file);
-
-	vidioc_try_fmt_vid_overlay(file, priv, f);
-
-	dev->overlay = f->fmt.win;
-	if (dev->component[COMP_PREVIEW]->enabled) {
-		set_overlay_params(dev,
-				   &dev->component[COMP_PREVIEW]->input[0]);
-	}
-
-	return 0;
-}
-
-static int vidioc_overlay(struct file *file, void *f, unsigned int on)
-{
-	int ret;
-	struct bcm2835_mmal_dev *dev = video_drvdata(file);
-	struct vchiq_mmal_port *src;
-	struct vchiq_mmal_port *dst;
-
-	if ((on && dev->component[COMP_PREVIEW]->enabled) ||
-	    (!on && !dev->component[COMP_PREVIEW]->enabled))
-		return 0;	/* already in requested state */
-
-	src = &dev->component[COMP_CAMERA]->output[CAM_PORT_PREVIEW];
-
-	if (!on) {
-		/* disconnect preview ports and disable component */
-		ret = vchiq_mmal_port_disable(dev->instance, src);
-		if (!ret)
-			ret = vchiq_mmal_port_connect_tunnel(dev->instance, src,
-							     NULL);
-		if (ret >= 0)
-			ret = vchiq_mmal_component_disable(dev->instance,
-							   dev->component[COMP_PREVIEW]);
-
-		disable_camera(dev);
-		return ret;
-	}
-
-	/* set preview port format and connect it to output */
-	dst = &dev->component[COMP_PREVIEW]->input[0];
-
-	ret = vchiq_mmal_port_set_format(dev->instance, src);
-	if (ret < 0)
-		return ret;
-
-	ret = set_overlay_params(dev, dst);
-	if (ret < 0)
-		return ret;
-
-	if (enable_camera(dev) < 0)
-		return -EINVAL;
-
-	ret = vchiq_mmal_component_enable(dev->instance,
-					  dev->component[COMP_PREVIEW]);
-	if (ret < 0)
-		return ret;
-
-	v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev, "connecting %p to %p\n",
-		 src, dst);
-	ret = vchiq_mmal_port_connect_tunnel(dev->instance, src, dst);
-	if (ret)
-		return ret;
-
-	return vchiq_mmal_port_enable(dev->instance, src, NULL);
-}
-
-static int vidioc_g_fbuf(struct file *file, void *fh,
-			 struct v4l2_framebuffer *a)
-{
-	/* The video overlay must stay within the framebuffer and can't be
-	 * positioned independently.
-	 */
-	struct bcm2835_mmal_dev *dev = video_drvdata(file);
-	struct vchiq_mmal_port *preview_port =
-		&dev->component[COMP_CAMERA]->output[CAM_PORT_PREVIEW];
-
-	a->capability = V4L2_FBUF_CAP_EXTERNOVERLAY |
-			V4L2_FBUF_CAP_GLOBAL_ALPHA;
-	a->flags = V4L2_FBUF_FLAG_OVERLAY;
-	a->fmt.width = preview_port->es.video.width;
-	a->fmt.height = preview_port->es.video.height;
-	a->fmt.pixelformat = V4L2_PIX_FMT_YUV420;
-	a->fmt.bytesperline = preview_port->es.video.width;
-	a->fmt.sizeimage = (preview_port->es.video.width *
-			       preview_port->es.video.height * 3) >> 1;
-	a->fmt.colorspace = V4L2_COLORSPACE_SMPTE170M;
-
-	return 0;
-}
-
-/* input ioctls */
-static int vidioc_enum_input(struct file *file, void *priv,
-			     struct v4l2_input *inp)
-{
-	/* only a single camera input */
-	if (inp->index)
-		return -EINVAL;
-
-	inp->type = V4L2_INPUT_TYPE_CAMERA;
-	snprintf((char *)inp->name, sizeof(inp->name), "Camera %u", inp->index);
-	return 0;
-}
-
-static int vidioc_g_input(struct file *file, void *priv, unsigned int *i)
-{
-	*i = 0;
-	return 0;
-}
-
-static int vidioc_s_input(struct file *file, void *priv, unsigned int i)
-{
-	if (i)
-		return -EINVAL;
-
-	return 0;
-}
-
-/* capture ioctls */
-static int vidioc_querycap(struct file *file, void *priv,
-			   struct v4l2_capability *cap)
-{
-	struct bcm2835_mmal_dev *dev = video_drvdata(file);
-	u32 major;
-	u32 minor;
-
-	vchiq_mmal_version(dev->instance, &major, &minor);
-
-	strscpy(cap->driver, "bcm2835 mmal", sizeof(cap->driver));
-	snprintf((char *)cap->card, sizeof(cap->card), "mmal service %d.%d", major, minor);
-
-	snprintf((char *)cap->bus_info, sizeof(cap->bus_info), "platform:%s", dev->v4l2_dev.name);
-	return 0;
-}
-
-static int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,
-				   struct v4l2_fmtdesc *f)
-{
-	struct mmal_fmt *fmt;
-
-	if (f->index >= ARRAY_SIZE(formats))
-		return -EINVAL;
-
-	fmt = &formats[f->index];
-
-	f->pixelformat = fmt->fourcc;
-
-	return 0;
-}
-
-static int vidioc_g_fmt_vid_cap(struct file *file, void *priv,
-				struct v4l2_format *f)
-{
-	struct bcm2835_mmal_dev *dev = video_drvdata(file);
-
-	f->fmt.pix.width = dev->capture.width;
-	f->fmt.pix.height = dev->capture.height;
-	f->fmt.pix.field = V4L2_FIELD_NONE;
-	f->fmt.pix.pixelformat = dev->capture.fmt->fourcc;
-	f->fmt.pix.bytesperline = dev->capture.stride;
-	f->fmt.pix.sizeimage = dev->capture.buffersize;
-
-	if (dev->capture.fmt->fourcc == V4L2_PIX_FMT_RGB24)
-		f->fmt.pix.colorspace = V4L2_COLORSPACE_SRGB;
-	else if (dev->capture.fmt->fourcc == V4L2_PIX_FMT_JPEG)
-		f->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;
-	else
-		f->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;
-	f->fmt.pix.priv = 0;
-
-	v4l2_dump_pix_format(1, bcm2835_v4l2_debug, &dev->v4l2_dev, &f->fmt.pix,
-			     __func__);
-	return 0;
-}
-
-static int vidioc_try_fmt_vid_cap(struct file *file, void *priv,
-				  struct v4l2_format *f)
-{
-	struct bcm2835_mmal_dev *dev = video_drvdata(file);
-	struct mmal_fmt *mfmt;
-
-	mfmt = get_format(f);
-	if (!mfmt) {
-		v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-			 "Fourcc format (0x%08x) unknown.\n",
-			 f->fmt.pix.pixelformat);
-		f->fmt.pix.pixelformat = formats[0].fourcc;
-		mfmt = get_format(f);
-	}
-
-	f->fmt.pix.field = V4L2_FIELD_NONE;
-
-	v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-		 "Clipping/aligning %dx%d format %08X\n",
-		 f->fmt.pix.width, f->fmt.pix.height, f->fmt.pix.pixelformat);
-
-	v4l_bound_align_image(&f->fmt.pix.width, MIN_WIDTH, dev->max_width, 1,
-			      &f->fmt.pix.height, MIN_HEIGHT, dev->max_height,
-			      1, 0);
-	f->fmt.pix.bytesperline = f->fmt.pix.width * mfmt->ybbp;
-	if (!mfmt->remove_padding) {
-		if (mfmt->depth == 24) {
-			/*
-			 * 24bpp is a pain as we can't use simple masking.
-			 * Min stride is width aligned to 16, times 24bpp.
-			 */
-			f->fmt.pix.bytesperline =
-				((f->fmt.pix.width + 15) & ~15) * 3;
-		} else {
-			/*
-			 * GPU isn't removing padding, so stride is aligned to
-			 * 32
-			 */
-			int align_mask = ((32 * mfmt->depth) >> 3) - 1;
-
-			f->fmt.pix.bytesperline =
-				(f->fmt.pix.bytesperline + align_mask) &
-							~align_mask;
-		}
-		v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-			 "Not removing padding, so bytes/line = %d\n",
-			 f->fmt.pix.bytesperline);
-	}
-
-	/* Image buffer has to be padded to allow for alignment, even though
-	 * we sometimes then remove that padding before delivering the buffer.
-	 */
-	f->fmt.pix.sizeimage = ((f->fmt.pix.height + 15) & ~15) *
-			(((f->fmt.pix.width + 31) & ~31) * mfmt->depth) >> 3;
-
-	if ((mfmt->flags & V4L2_FMT_FLAG_COMPRESSED) &&
-	    f->fmt.pix.sizeimage < MIN_BUFFER_SIZE)
-		f->fmt.pix.sizeimage = MIN_BUFFER_SIZE;
-
-	if (f->fmt.pix.pixelformat == V4L2_PIX_FMT_RGB24)
-		f->fmt.pix.colorspace = V4L2_COLORSPACE_SRGB;
-	else if (f->fmt.pix.pixelformat == V4L2_PIX_FMT_JPEG)
-		f->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;
-	else
-		f->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;
-	f->fmt.pix.priv = 0;
-
-	v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-		 "Now %dx%d format %08X\n",
-		f->fmt.pix.width, f->fmt.pix.height, f->fmt.pix.pixelformat);
-
-	v4l2_dump_pix_format(1, bcm2835_v4l2_debug, &dev->v4l2_dev, &f->fmt.pix,
-			     __func__);
-	return 0;
-}
-
-static int mmal_setup_video_component(struct bcm2835_mmal_dev *dev,
-				      struct v4l2_format *f)
-{
-	bool overlay_enabled = !!dev->component[COMP_PREVIEW]->enabled;
-	struct vchiq_mmal_port *preview_port;
-	int ret;
-
-	preview_port = &dev->component[COMP_CAMERA]->output[CAM_PORT_PREVIEW];
-
-	/* Preview and encode ports need to match on resolution */
-	if (overlay_enabled) {
-		/* Need to disable the overlay before we can update
-		 * the resolution
-		 */
-		ret = vchiq_mmal_port_disable(dev->instance, preview_port);
-		if (!ret) {
-			ret = vchiq_mmal_port_connect_tunnel(dev->instance,
-							     preview_port,
-							     NULL);
-		}
-	}
-	preview_port->es.video.width = f->fmt.pix.width;
-	preview_port->es.video.height = f->fmt.pix.height;
-	preview_port->es.video.crop.x = 0;
-	preview_port->es.video.crop.y = 0;
-	preview_port->es.video.crop.width = f->fmt.pix.width;
-	preview_port->es.video.crop.height = f->fmt.pix.height;
-	preview_port->es.video.frame_rate.numerator =
-				  dev->capture.timeperframe.denominator;
-	preview_port->es.video.frame_rate.denominator =
-				  dev->capture.timeperframe.numerator;
-	ret = vchiq_mmal_port_set_format(dev->instance, preview_port);
-
-	if (overlay_enabled) {
-		ret = vchiq_mmal_port_connect_tunnel(dev->instance,
-						     preview_port,
-						     &dev->component[COMP_PREVIEW]->input[0]);
-		if (ret)
-			return ret;
-
-		ret = vchiq_mmal_port_enable(dev->instance, preview_port, NULL);
-	}
-
-	return ret;
-}
-
-static int mmal_setup_encode_component(struct bcm2835_mmal_dev *dev,
-				       struct v4l2_format *f,
-				       struct vchiq_mmal_port *port,
-				       struct vchiq_mmal_port *camera_port,
-				       struct vchiq_mmal_component *component)
-{
-	struct mmal_fmt *mfmt = get_format(f);
-	int ret;
-
-	v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-		 "vid_cap - set up encode comp\n");
-
-	/* configure buffering */
-	camera_port->current_buffer.size = camera_port->recommended_buffer.size;
-	camera_port->current_buffer.num = camera_port->recommended_buffer.num;
-
-	ret = vchiq_mmal_port_connect_tunnel(dev->instance, camera_port,
-					     &component->input[0]);
-	if (ret) {
-		v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-			 "%s failed to create connection\n", __func__);
-		/* ensure capture is not going to be tried */
-		dev->capture.port = NULL;
-		return ret;
-	}
-
-	port->es.video.width = f->fmt.pix.width;
-	port->es.video.height = f->fmt.pix.height;
-	port->es.video.crop.x = 0;
-	port->es.video.crop.y = 0;
-	port->es.video.crop.width = f->fmt.pix.width;
-	port->es.video.crop.height = f->fmt.pix.height;
-	port->es.video.frame_rate.numerator =
-		  dev->capture.timeperframe.denominator;
-	port->es.video.frame_rate.denominator =
-		  dev->capture.timeperframe.numerator;
-
-	port->format.encoding = mfmt->mmal;
-	port->format.encoding_variant = 0;
-	/* Set any encoding specific parameters */
-	switch (mfmt->mmal_component) {
-	case COMP_VIDEO_ENCODE:
-		port->format.bitrate = dev->capture.encode_bitrate;
-		break;
-	case COMP_IMAGE_ENCODE:
-		/* Could set EXIF parameters here */
-		break;
-	default:
-		break;
-	}
-
-	ret = vchiq_mmal_port_set_format(dev->instance, port);
-	if (ret) {
-		v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-			 "%s failed to set format %dx%d fmt %08X\n",
-			 __func__,
-			 f->fmt.pix.width,
-			 f->fmt.pix.height,
-			 f->fmt.pix.pixelformat);
-		return ret;
-	}
-
-	ret = vchiq_mmal_component_enable(dev->instance, component);
-	if (ret) {
-		v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-			 "%s Failed to enable encode components\n", __func__);
-		return ret;
-	}
-
-	/* configure buffering */
-	port->current_buffer.num = 1;
-	port->current_buffer.size = f->fmt.pix.sizeimage;
-	if (port->format.encoding == MMAL_ENCODING_JPEG) {
-		v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-			 "JPG - buf size now %d was %d\n",
-			 f->fmt.pix.sizeimage,
-			 port->current_buffer.size);
-		port->current_buffer.size =
-		    (f->fmt.pix.sizeimage < (100 << 10)) ?
-		    (100 << 10) : f->fmt.pix.sizeimage;
-	}
-	v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-		 "vid_cap - cur_buf.size set to %d\n", f->fmt.pix.sizeimage);
-	port->current_buffer.alignment = 0;
-
-	return 0;
-}
-
-static int mmal_setup_components(struct bcm2835_mmal_dev *dev,
-				 struct v4l2_format *f)
-{
-	int ret;
-	struct vchiq_mmal_port *port = NULL, *camera_port = NULL;
-	struct vchiq_mmal_component *encode_component = NULL;
-	struct mmal_fmt *mfmt = get_format(f);
-	bool remove_padding;
-
-	if (!mfmt)
-		return -EINVAL;
-
-	if (dev->capture.encode_component) {
-		v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-			 "vid_cap - disconnect previous tunnel\n");
-
-		/* Disconnect any previous connection */
-		vchiq_mmal_port_connect_tunnel(dev->instance,
-					       dev->capture.camera_port, NULL);
-		dev->capture.camera_port = NULL;
-		ret = vchiq_mmal_component_disable(dev->instance,
-						   dev->capture.encode_component);
-		if (ret)
-			v4l2_err(&dev->v4l2_dev,
-				 "Failed to disable encode component %d\n",
-				 ret);
-
-		dev->capture.encode_component = NULL;
-	}
-	/* format dependent port setup */
-	switch (mfmt->mmal_component) {
-	case COMP_CAMERA:
-		/* Make a further decision on port based on resolution */
-		if (f->fmt.pix.width <= max_video_width &&
-		    f->fmt.pix.height <= max_video_height)
-			camera_port =
-			    &dev->component[COMP_CAMERA]->output[CAM_PORT_VIDEO];
-		else
-			camera_port =
-			    &dev->component[COMP_CAMERA]->output[CAM_PORT_CAPTURE];
-		port = camera_port;
-		break;
-	case COMP_IMAGE_ENCODE:
-		encode_component = dev->component[COMP_IMAGE_ENCODE];
-		port = &dev->component[COMP_IMAGE_ENCODE]->output[0];
-		camera_port =
-		    &dev->component[COMP_CAMERA]->output[CAM_PORT_CAPTURE];
-		break;
-	case COMP_VIDEO_ENCODE:
-		encode_component = dev->component[COMP_VIDEO_ENCODE];
-		port = &dev->component[COMP_VIDEO_ENCODE]->output[0];
-		camera_port =
-		    &dev->component[COMP_CAMERA]->output[CAM_PORT_VIDEO];
-		break;
-	default:
-		break;
-	}
-
-	if (!port)
-		return -EINVAL;
-
-	if (encode_component)
-		camera_port->format.encoding = MMAL_ENCODING_OPAQUE;
-	else
-		camera_port->format.encoding = mfmt->mmal;
-
-	if (dev->rgb_bgr_swapped) {
-		if (camera_port->format.encoding == MMAL_ENCODING_RGB24)
-			camera_port->format.encoding = MMAL_ENCODING_BGR24;
-		else if (camera_port->format.encoding == MMAL_ENCODING_BGR24)
-			camera_port->format.encoding = MMAL_ENCODING_RGB24;
-	}
-
-	remove_padding = mfmt->remove_padding;
-	vchiq_mmal_port_parameter_set(dev->instance, camera_port,
-				      MMAL_PARAMETER_NO_IMAGE_PADDING,
-				      &remove_padding, sizeof(remove_padding));
-
-	camera_port->format.encoding_variant = 0;
-	camera_port->es.video.width = f->fmt.pix.width;
-	camera_port->es.video.height = f->fmt.pix.height;
-	camera_port->es.video.crop.x = 0;
-	camera_port->es.video.crop.y = 0;
-	camera_port->es.video.crop.width = f->fmt.pix.width;
-	camera_port->es.video.crop.height = f->fmt.pix.height;
-	camera_port->es.video.frame_rate.numerator = 0;
-	camera_port->es.video.frame_rate.denominator = 1;
-	camera_port->es.video.color_space = MMAL_COLOR_SPACE_JPEG_JFIF;
-
-	ret = vchiq_mmal_port_set_format(dev->instance, camera_port);
-
-	if (!ret &&
-	    camera_port ==
-	    &dev->component[COMP_CAMERA]->output[CAM_PORT_VIDEO]) {
-		ret = mmal_setup_video_component(dev, f);
-	}
-
-	if (ret) {
-		v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-			 "%s failed to set format %dx%d %08X\n", __func__,
-			 f->fmt.pix.width, f->fmt.pix.height,
-			 f->fmt.pix.pixelformat);
-		/* ensure capture is not going to be tried */
-		dev->capture.port = NULL;
-		return ret;
-	}
-
-	if (encode_component) {
-		ret = mmal_setup_encode_component(dev, f, port,
-						  camera_port,
-						  encode_component);
-
-		if (ret)
-			return ret;
-	} else {
-		/* configure buffering */
-		camera_port->current_buffer.num = 1;
-		camera_port->current_buffer.size = f->fmt.pix.sizeimage;
-		camera_port->current_buffer.alignment = 0;
-	}
-
-	dev->capture.fmt = mfmt;
-	dev->capture.stride = f->fmt.pix.bytesperline;
-	dev->capture.width = camera_port->es.video.crop.width;
-	dev->capture.height = camera_port->es.video.crop.height;
-	dev->capture.buffersize = port->current_buffer.size;
-
-	/* select port for capture */
-	dev->capture.port = port;
-	dev->capture.camera_port = camera_port;
-	dev->capture.encode_component = encode_component;
-	v4l2_dbg(1, bcm2835_v4l2_debug,
-		 &dev->v4l2_dev,
-		"Set dev->capture.fmt %08X, %dx%d, stride %d, size %d",
-		port->format.encoding,
-		dev->capture.width, dev->capture.height,
-		dev->capture.stride, dev->capture.buffersize);
-
-	/* todo: Need to convert the vchiq/mmal error into a v4l2 error. */
-	return ret;
-}
-
-static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
-				struct v4l2_format *f)
-{
-	int ret;
-	struct bcm2835_mmal_dev *dev = video_drvdata(file);
-	struct mmal_fmt *mfmt;
-
-	/* try the format to set valid parameters */
-	ret = vidioc_try_fmt_vid_cap(file, priv, f);
-	if (ret) {
-		v4l2_err(&dev->v4l2_dev,
-			 "vid_cap - vidioc_try_fmt_vid_cap failed\n");
-		return ret;
-	}
-
-	/* if a capture is running refuse to set format */
-	if (vb2_is_busy(&dev->capture.vb_vidq)) {
-		v4l2_info(&dev->v4l2_dev, "%s device busy\n", __func__);
-		return -EBUSY;
-	}
-
-	/* If the format is unsupported v4l2 says we should switch to
-	 * a supported one and not return an error.
-	 */
-	mfmt = get_format(f);
-	if (!mfmt) {
-		v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-			 "Fourcc format (0x%08x) unknown.\n",
-			 f->fmt.pix.pixelformat);
-		f->fmt.pix.pixelformat = formats[0].fourcc;
-		mfmt = get_format(f);
-	}
-
-	ret = mmal_setup_components(dev, f);
-	if (ret) {
-		v4l2_err(&dev->v4l2_dev,
-			 "%s: failed to setup mmal components: %d\n",
-			 __func__, ret);
-		ret = -EINVAL;
-	}
-
-	return ret;
-}
-
-static int vidioc_enum_framesizes(struct file *file, void *fh,
-				  struct v4l2_frmsizeenum *fsize)
-{
-	struct bcm2835_mmal_dev *dev = video_drvdata(file);
-	static const struct v4l2_frmsize_stepwise sizes = {
-		MIN_WIDTH, 0, 2,
-		MIN_HEIGHT, 0, 2
-	};
-	int i;
-
-	if (fsize->index)
-		return -EINVAL;
-	for (i = 0; i < ARRAY_SIZE(formats); i++)
-		if (formats[i].fourcc == fsize->pixel_format)
-			break;
-	if (i == ARRAY_SIZE(formats))
-		return -EINVAL;
-	fsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;
-	fsize->stepwise = sizes;
-	fsize->stepwise.max_width = dev->max_width;
-	fsize->stepwise.max_height = dev->max_height;
-	return 0;
-}
-
-/* timeperframe is arbitrary and continuous */
-static int vidioc_enum_frameintervals(struct file *file, void *priv,
-				      struct v4l2_frmivalenum *fival)
-{
-	struct bcm2835_mmal_dev *dev = video_drvdata(file);
-	int i;
-
-	if (fival->index)
-		return -EINVAL;
-
-	for (i = 0; i < ARRAY_SIZE(formats); i++)
-		if (formats[i].fourcc == fival->pixel_format)
-			break;
-	if (i == ARRAY_SIZE(formats))
-		return -EINVAL;
-
-	/* regarding width & height - we support any within range */
-	if (fival->width < MIN_WIDTH || fival->width > dev->max_width ||
-	    fival->height < MIN_HEIGHT || fival->height > dev->max_height)
-		return -EINVAL;
-
-	fival->type = V4L2_FRMIVAL_TYPE_CONTINUOUS;
-
-	/* fill in stepwise (step=1.0 is required by V4L2 spec) */
-	fival->stepwise.min  = tpf_min;
-	fival->stepwise.max  = tpf_max;
-	fival->stepwise.step = (struct v4l2_fract) {1, 1};
-
-	return 0;
-}
-
-static int vidioc_g_parm(struct file *file, void *priv,
-			 struct v4l2_streamparm *parm)
-{
-	struct bcm2835_mmal_dev *dev = video_drvdata(file);
-
-	if (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
-		return -EINVAL;
-
-	parm->parm.capture.capability   = V4L2_CAP_TIMEPERFRAME;
-	parm->parm.capture.timeperframe = dev->capture.timeperframe;
-	parm->parm.capture.readbuffers  = 1;
-	return 0;
-}
-
-static int vidioc_s_parm(struct file *file, void *priv,
-			 struct v4l2_streamparm *parm)
-{
-	struct bcm2835_mmal_dev *dev = video_drvdata(file);
-	struct v4l2_fract tpf;
-
-	if (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
-		return -EINVAL;
-
-	tpf = parm->parm.capture.timeperframe;
-
-	/* tpf: {*, 0} resets timing; clip to [min, max]*/
-	tpf = tpf.denominator ? tpf : tpf_default;
-	tpf = V4L2_FRACT_COMPARE(tpf, <, tpf_min) ? tpf_min : tpf;
-	tpf = V4L2_FRACT_COMPARE(tpf, >, tpf_max) ? tpf_max : tpf;
-
-	dev->capture.timeperframe = tpf;
-	parm->parm.capture.timeperframe = tpf;
-	parm->parm.capture.readbuffers  = 1;
-	parm->parm.capture.capability   = V4L2_CAP_TIMEPERFRAME;
-
-	set_framerate_params(dev);
-
-	return 0;
-}
-
-static const struct v4l2_ioctl_ops camera0_ioctl_ops = {
-	/* overlay */
-	.vidioc_enum_fmt_vid_overlay = vidioc_enum_fmt_vid_overlay,
-	.vidioc_g_fmt_vid_overlay = vidioc_g_fmt_vid_overlay,
-	.vidioc_try_fmt_vid_overlay = vidioc_try_fmt_vid_overlay,
-	.vidioc_s_fmt_vid_overlay = vidioc_s_fmt_vid_overlay,
-	.vidioc_overlay = vidioc_overlay,
-	.vidioc_g_fbuf = vidioc_g_fbuf,
-
-	/* inputs */
-	.vidioc_enum_input = vidioc_enum_input,
-	.vidioc_g_input = vidioc_g_input,
-	.vidioc_s_input = vidioc_s_input,
-
-	/* capture */
-	.vidioc_querycap = vidioc_querycap,
-	.vidioc_enum_fmt_vid_cap = vidioc_enum_fmt_vid_cap,
-	.vidioc_g_fmt_vid_cap = vidioc_g_fmt_vid_cap,
-	.vidioc_try_fmt_vid_cap = vidioc_try_fmt_vid_cap,
-	.vidioc_s_fmt_vid_cap = vidioc_s_fmt_vid_cap,
-
-	/* buffer management */
-	.vidioc_reqbufs = vb2_ioctl_reqbufs,
-	.vidioc_create_bufs = vb2_ioctl_create_bufs,
-	.vidioc_prepare_buf = vb2_ioctl_prepare_buf,
-	.vidioc_querybuf = vb2_ioctl_querybuf,
-	.vidioc_qbuf = vb2_ioctl_qbuf,
-	.vidioc_dqbuf = vb2_ioctl_dqbuf,
-	.vidioc_enum_framesizes = vidioc_enum_framesizes,
-	.vidioc_enum_frameintervals = vidioc_enum_frameintervals,
-	.vidioc_g_parm        = vidioc_g_parm,
-	.vidioc_s_parm        = vidioc_s_parm,
-	.vidioc_streamon = vb2_ioctl_streamon,
-	.vidioc_streamoff = vb2_ioctl_streamoff,
-
-	.vidioc_log_status = v4l2_ctrl_log_status,
-	.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,
-	.vidioc_unsubscribe_event = v4l2_event_unsubscribe,
-};
-
-/* ------------------------------------------------------------------
- *	Driver init/finalise
- * ------------------------------------------------------------------
- */
-
-static const struct v4l2_file_operations camera0_fops = {
-	.owner = THIS_MODULE,
-	.open = v4l2_fh_open,
-	.release = vb2_fop_release,
-	.read = vb2_fop_read,
-	.poll = vb2_fop_poll,
-	.unlocked_ioctl = video_ioctl2,	/* V4L2 ioctl handler */
-	.mmap = vb2_fop_mmap,
-};
-
-static const struct video_device vdev_template = {
-	.name = "camera0",
-	.fops = &camera0_fops,
-	.ioctl_ops = &camera0_ioctl_ops,
-	.release = video_device_release_empty,
-	.device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OVERLAY |
-		       V4L2_CAP_STREAMING | V4L2_CAP_READWRITE,
-};
-
-/* Returns the number of cameras, and also the max resolution supported
- * by those cameras.
- */
-static int get_num_cameras(struct vchiq_mmal_instance *instance,
-			   unsigned int resolutions[][2], int num_resolutions)
-{
-	int ret;
-	struct vchiq_mmal_component  *cam_info_component;
-	struct mmal_parameter_camera_info cam_info = {0};
-	u32 param_size = sizeof(cam_info);
-	int i;
-
-	/* create a camera_info component */
-	ret = vchiq_mmal_component_init(instance, "camera_info",
-					&cam_info_component);
-	if (ret < 0)
-		/* Unusual failure - let's guess one camera. */
-		return 1;
-
-	if (vchiq_mmal_port_parameter_get(instance,
-					  &cam_info_component->control,
-					  MMAL_PARAMETER_CAMERA_INFO,
-					  &cam_info,
-					  &param_size)) {
-		pr_info("Failed to get camera info\n");
-	}
-	for (i = 0;
-	     i < min_t(unsigned int, cam_info.num_cameras, num_resolutions);
-	     i++) {
-		resolutions[i][0] = cam_info.cameras[i].max_width;
-		resolutions[i][1] = cam_info.cameras[i].max_height;
-	}
-
-	vchiq_mmal_component_finalise(instance,
-				      cam_info_component);
-
-	return cam_info.num_cameras;
-}
-
-static int set_camera_parameters(struct vchiq_mmal_instance *instance,
-				 struct vchiq_mmal_component *camera,
-				 struct bcm2835_mmal_dev *dev)
-{
-	struct mmal_parameter_camera_config cam_config = {
-		.max_stills_w = dev->max_width,
-		.max_stills_h = dev->max_height,
-		.stills_yuv422 = 1,
-		.one_shot_stills = 1,
-		.max_preview_video_w = (max_video_width > 1920) ?
-						max_video_width : 1920,
-		.max_preview_video_h = (max_video_height > 1088) ?
-						max_video_height : 1088,
-		.num_preview_video_frames = 3,
-		.stills_capture_circular_buffer_height = 0,
-		.fast_preview_resume = 0,
-		.use_stc_timestamp = MMAL_PARAM_TIMESTAMP_MODE_RAW_STC
-	};
-
-	return vchiq_mmal_port_parameter_set(instance, &camera->control,
-					    MMAL_PARAMETER_CAMERA_CONFIG,
-					    &cam_config, sizeof(cam_config));
-}
-
-#define MAX_SUPPORTED_ENCODINGS 20
-
-/* MMAL instance and component init */
-static int mmal_init(struct bcm2835_mmal_dev *dev)
-{
-	int ret;
-	struct mmal_es_format_local *format;
-	u32 supported_encodings[MAX_SUPPORTED_ENCODINGS];
-	u32 param_size;
-	struct vchiq_mmal_component  *camera;
-
-	ret = vchiq_mmal_init(dev->v4l2_dev.dev, &dev->instance);
-	if (ret < 0) {
-		v4l2_err(&dev->v4l2_dev, "%s: vchiq mmal init failed %d\n",
-			 __func__, ret);
-		return ret;
-	}
-
-	/* get the camera component ready */
-	ret = vchiq_mmal_component_init(dev->instance, "ril.camera",
-					&dev->component[COMP_CAMERA]);
-	if (ret < 0)
-		goto unreg_mmal;
-
-	camera = dev->component[COMP_CAMERA];
-	if (camera->outputs < CAM_PORT_COUNT) {
-		v4l2_err(&dev->v4l2_dev, "%s: too few camera outputs %d needed %d\n",
-			 __func__, camera->outputs, CAM_PORT_COUNT);
-		ret = -EINVAL;
-		goto unreg_camera;
-	}
-
-	ret = set_camera_parameters(dev->instance,
-				    camera,
-				    dev);
-	if (ret < 0) {
-		v4l2_err(&dev->v4l2_dev, "%s: unable to set camera parameters: %d\n",
-			 __func__, ret);
-		goto unreg_camera;
-	}
-
-	/* There was an error in the firmware that meant the camera component
-	 * produced BGR instead of RGB.
-	 * This is now fixed, but in order to support the old firmwares, we
-	 * have to check.
-	 */
-	dev->rgb_bgr_swapped = true;
-	param_size = sizeof(supported_encodings);
-	ret = vchiq_mmal_port_parameter_get(dev->instance,
-					    &camera->output[CAM_PORT_CAPTURE],
-					    MMAL_PARAMETER_SUPPORTED_ENCODINGS,
-					    &supported_encodings,
-					    &param_size);
-	if (ret == 0) {
-		int i;
-
-		for (i = 0; i < param_size / sizeof(u32); i++) {
-			if (supported_encodings[i] == MMAL_ENCODING_BGR24) {
-				/* Found BGR24 first - old firmware. */
-				break;
-			}
-			if (supported_encodings[i] == MMAL_ENCODING_RGB24) {
-				/* Found RGB24 first
-				 * new firmware, so use RGB24.
-				 */
-				dev->rgb_bgr_swapped = false;
-			break;
-			}
-		}
-	}
-	format = &camera->output[CAM_PORT_PREVIEW].format;
-
-	format->encoding = MMAL_ENCODING_OPAQUE;
-	format->encoding_variant = MMAL_ENCODING_I420;
-
-	format->es->video.width = 1024;
-	format->es->video.height = 768;
-	format->es->video.crop.x = 0;
-	format->es->video.crop.y = 0;
-	format->es->video.crop.width = 1024;
-	format->es->video.crop.height = 768;
-	format->es->video.frame_rate.numerator = 0; /* Rely on fps_range */
-	format->es->video.frame_rate.denominator = 1;
-
-	format = &camera->output[CAM_PORT_VIDEO].format;
-
-	format->encoding = MMAL_ENCODING_OPAQUE;
-	format->encoding_variant = MMAL_ENCODING_I420;
-
-	format->es->video.width = 1024;
-	format->es->video.height = 768;
-	format->es->video.crop.x = 0;
-	format->es->video.crop.y = 0;
-	format->es->video.crop.width = 1024;
-	format->es->video.crop.height = 768;
-	format->es->video.frame_rate.numerator = 0; /* Rely on fps_range */
-	format->es->video.frame_rate.denominator = 1;
-
-	format = &camera->output[CAM_PORT_CAPTURE].format;
-
-	format->encoding = MMAL_ENCODING_OPAQUE;
-
-	format->es->video.width = 2592;
-	format->es->video.height = 1944;
-	format->es->video.crop.x = 0;
-	format->es->video.crop.y = 0;
-	format->es->video.crop.width = 2592;
-	format->es->video.crop.height = 1944;
-	format->es->video.frame_rate.numerator = 0; /* Rely on fps_range */
-	format->es->video.frame_rate.denominator = 1;
-
-	dev->capture.width = format->es->video.width;
-	dev->capture.height = format->es->video.height;
-	dev->capture.fmt = &formats[0];
-	dev->capture.encode_component = NULL;
-	dev->capture.timeperframe = tpf_default;
-	dev->capture.enc_profile = V4L2_MPEG_VIDEO_H264_PROFILE_HIGH;
-	dev->capture.enc_level = V4L2_MPEG_VIDEO_H264_LEVEL_4_0;
-
-	/* get the preview component ready */
-	ret = vchiq_mmal_component_init(dev->instance, "ril.video_render",
-					&dev->component[COMP_PREVIEW]);
-	if (ret < 0)
-		goto unreg_camera;
-
-	if (dev->component[COMP_PREVIEW]->inputs < 1) {
-		ret = -EINVAL;
-		v4l2_err(&dev->v4l2_dev, "%s: too few input ports %d needed %d\n",
-			 __func__, dev->component[COMP_PREVIEW]->inputs, 1);
-		goto unreg_preview;
-	}
-
-	/* get the image encoder component ready */
-	ret = vchiq_mmal_component_init(dev->instance, "ril.image_encode",
-					&dev->component[COMP_IMAGE_ENCODE]);
-	if (ret < 0)
-		goto unreg_preview;
-
-	if (dev->component[COMP_IMAGE_ENCODE]->inputs < 1) {
-		ret = -EINVAL;
-		v4l2_err(&dev->v4l2_dev, "%s: too few input ports %d needed %d\n",
-			 __func__, dev->component[COMP_IMAGE_ENCODE]->inputs,
-			 1);
-		goto unreg_image_encoder;
-	}
-
-	/* get the video encoder component ready */
-	ret = vchiq_mmal_component_init(dev->instance, "ril.video_encode",
-					&dev->component[COMP_VIDEO_ENCODE]);
-	if (ret < 0)
-		goto unreg_image_encoder;
-
-	if (dev->component[COMP_VIDEO_ENCODE]->inputs < 1) {
-		ret = -EINVAL;
-		v4l2_err(&dev->v4l2_dev, "%s: too few input ports %d needed %d\n",
-			 __func__, dev->component[COMP_VIDEO_ENCODE]->inputs,
-			 1);
-		goto unreg_vid_encoder;
-	}
-
-	{
-		struct vchiq_mmal_port *encoder_port =
-			&dev->component[COMP_VIDEO_ENCODE]->output[0];
-		encoder_port->format.encoding = MMAL_ENCODING_H264;
-		ret = vchiq_mmal_port_set_format(dev->instance,
-						 encoder_port);
-	}
-
-	{
-		unsigned int enable = 1;
-
-		vchiq_mmal_port_parameter_set(dev->instance,
-					      &dev->component[COMP_VIDEO_ENCODE]->control,
-					      MMAL_PARAMETER_VIDEO_IMMUTABLE_INPUT,
-					      &enable,
-					      sizeof(enable));
-
-		vchiq_mmal_port_parameter_set(dev->instance,
-					      &dev->component[COMP_VIDEO_ENCODE]->control,
-					      MMAL_PARAMETER_MINIMISE_FRAGMENTATION,
-					      &enable,
-					      sizeof(enable));
-	}
-	ret = bcm2835_mmal_set_all_camera_controls(dev);
-	if (ret < 0) {
-		v4l2_err(&dev->v4l2_dev, "%s: failed to set all camera controls: %d\n",
-			 __func__, ret);
-		goto unreg_vid_encoder;
-	}
-
-	return 0;
-
-unreg_vid_encoder:
-	pr_err("Cleanup: Destroy video encoder\n");
-	vchiq_mmal_component_finalise(dev->instance,
-				      dev->component[COMP_VIDEO_ENCODE]);
-
-unreg_image_encoder:
-	pr_err("Cleanup: Destroy image encoder\n");
-	vchiq_mmal_component_finalise(dev->instance,
-				      dev->component[COMP_IMAGE_ENCODE]);
-
-unreg_preview:
-	pr_err("Cleanup: Destroy video render\n");
-	vchiq_mmal_component_finalise(dev->instance,
-				      dev->component[COMP_PREVIEW]);
-
-unreg_camera:
-	pr_err("Cleanup: Destroy camera\n");
-	vchiq_mmal_component_finalise(dev->instance,
-				      dev->component[COMP_CAMERA]);
-
-unreg_mmal:
-	vchiq_mmal_finalise(dev->instance);
-	return ret;
-}
-
-static int bcm2835_mmal_init_device(struct bcm2835_mmal_dev *dev, struct video_device *vfd)
-{
-	int ret;
-
-	*vfd = vdev_template;
-
-	vfd->v4l2_dev = &dev->v4l2_dev;
-
-	vfd->lock = &dev->mutex;
-
-	vfd->queue = &dev->capture.vb_vidq;
-
-	/* video device needs to be able to access instance data */
-	video_set_drvdata(vfd, dev);
-
-	ret = video_register_device(vfd, VFL_TYPE_VIDEO,
-				    video_nr[dev->camera_num]);
-	if (ret < 0)
-		return ret;
-
-	v4l2_info(vfd->v4l2_dev,
-		  "V4L2 device registered as %s - stills mode > %dx%d\n",
-		  video_device_node_name(vfd),
-		  max_video_width, max_video_height);
-
-	return 0;
-}
-
-static void bcm2835_cleanup_instance(struct bcm2835_mmal_dev *dev)
-{
-	if (!dev)
-		return;
-
-	v4l2_info(&dev->v4l2_dev, "unregistering %s\n",
-		  video_device_node_name(&dev->vdev));
-
-	video_unregister_device(&dev->vdev);
-
-	if (dev->capture.encode_component) {
-		v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-			 "mmal_exit - disconnect tunnel\n");
-		vchiq_mmal_port_connect_tunnel(dev->instance,
-					       dev->capture.camera_port, NULL);
-		vchiq_mmal_component_disable(dev->instance,
-					     dev->capture.encode_component);
-	}
-	vchiq_mmal_component_disable(dev->instance,
-				     dev->component[COMP_CAMERA]);
-
-	vchiq_mmal_component_finalise(dev->instance,
-				      dev->component[COMP_VIDEO_ENCODE]);
-
-	vchiq_mmal_component_finalise(dev->instance,
-				      dev->component[COMP_IMAGE_ENCODE]);
-
-	vchiq_mmal_component_finalise(dev->instance,
-				      dev->component[COMP_PREVIEW]);
-
-	vchiq_mmal_component_finalise(dev->instance,
-				      dev->component[COMP_CAMERA]);
-
-	v4l2_ctrl_handler_free(&dev->ctrl_handler);
-
-	v4l2_device_unregister(&dev->v4l2_dev);
-
-	kfree(dev);
-}
-
-static struct v4l2_format default_v4l2_format = {
-	.fmt.pix.pixelformat = V4L2_PIX_FMT_JPEG,
-	.fmt.pix.width = 1024,
-	.fmt.pix.bytesperline = 0,
-	.fmt.pix.height = 768,
-	.fmt.pix.sizeimage = 1024 * 768,
-};
-
-static int bcm2835_mmal_probe(struct vchiq_device *device)
-{
-	int ret;
-	struct bcm2835_mmal_dev *dev;
-	struct vb2_queue *q;
-	int camera;
-	unsigned int num_cameras;
-	struct vchiq_mmal_instance *instance;
-	unsigned int resolutions[MAX_BCM2835_CAMERAS][2];
-	int i;
-
-	ret = dma_set_mask_and_coherent(&device->dev, DMA_BIT_MASK(32));
-	if (ret) {
-		dev_err(&device->dev, "dma_set_mask_and_coherent failed: %d\n", ret);
-		return ret;
-	}
-
-	ret = vchiq_mmal_init(&device->dev, &instance);
-	if (ret < 0)
-		return ret;
-
-	num_cameras = get_num_cameras(instance,
-				      resolutions,
-				      MAX_BCM2835_CAMERAS);
-
-	if (num_cameras < 1) {
-		ret = -ENODEV;
-		goto cleanup_mmal;
-	}
-
-	if (num_cameras > MAX_BCM2835_CAMERAS)
-		num_cameras = MAX_BCM2835_CAMERAS;
-
-	for (camera = 0; camera < num_cameras; camera++) {
-		dev = kzalloc(sizeof(*dev), GFP_KERNEL);
-		if (!dev) {
-			ret = -ENOMEM;
-			goto cleanup_gdev;
-		}
-
-		/* v4l2 core mutex used to protect all fops and v4l2 ioctls. */
-		mutex_init(&dev->mutex);
-		dev->max_width = resolutions[camera][0];
-		dev->max_height = resolutions[camera][1];
-
-		/* setup device defaults */
-		dev->overlay.w.left = 150;
-		dev->overlay.w.top = 50;
-		dev->overlay.w.width = 1024;
-		dev->overlay.w.height = 768;
-		dev->overlay.clipcount = 0;
-		dev->overlay.field = V4L2_FIELD_NONE;
-		dev->overlay.global_alpha = 255;
-
-		dev->capture.fmt = &formats[3]; /* JPEG */
-
-		/* v4l device registration */
-		dev->camera_num = v4l2_device_set_name(&dev->v4l2_dev, KBUILD_MODNAME,
-						       &camera_instance);
-		ret = v4l2_device_register(NULL, &dev->v4l2_dev);
-		if (ret) {
-			dev_err(&device->dev, "%s: could not register V4L2 device: %d\n",
-				__func__, ret);
-			goto free_dev;
-		}
-		dev->v4l2_dev.dev = &device->dev;
-
-		/* setup v4l controls */
-		ret = bcm2835_mmal_init_controls(dev, &dev->ctrl_handler);
-		if (ret < 0) {
-			v4l2_err(&dev->v4l2_dev, "%s: could not init controls: %d\n",
-				 __func__, ret);
-			goto unreg_dev;
-		}
-		dev->v4l2_dev.ctrl_handler = &dev->ctrl_handler;
-
-		/* mmal init */
-		dev->instance = instance;
-		ret = mmal_init(dev);
-		if (ret < 0) {
-			v4l2_err(&dev->v4l2_dev, "%s: mmal init failed: %d\n",
-				 __func__, ret);
-			goto unreg_dev;
-		}
-		/* initialize queue */
-		q = &dev->capture.vb_vidq;
-		memset(q, 0, sizeof(*q));
-		q->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-		q->io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ;
-		q->drv_priv = dev;
-		q->buf_struct_size = sizeof(struct vb2_mmal_buffer);
-		q->ops = &bcm2835_mmal_video_qops;
-		q->mem_ops = &vb2_vmalloc_memops;
-		q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
-		q->lock = &dev->mutex;
-		ret = vb2_queue_init(q);
-		if (ret < 0)
-			goto unreg_dev;
-
-		/* initialise video devices */
-		ret = bcm2835_mmal_init_device(dev, &dev->vdev);
-		if (ret < 0) {
-			v4l2_err(&dev->v4l2_dev, "%s: could not init device: %d\n",
-				 __func__, ret);
-			goto unreg_dev;
-		}
-
-		/* Really want to call vidioc_s_fmt_vid_cap with the default
-		 * format, but currently the APIs don't join up.
-		 */
-		ret = mmal_setup_components(dev, &default_v4l2_format);
-		if (ret < 0) {
-			v4l2_err(&dev->v4l2_dev, "%s: could not setup components: %d\n",
-				 __func__, ret);
-			goto unreg_dev;
-		}
-
-		v4l2_info(&dev->v4l2_dev, "Broadcom 2835 MMAL video capture loaded.\n");
-
-		gdev[camera] = dev;
-	}
-	return 0;
-
-unreg_dev:
-	v4l2_ctrl_handler_free(&dev->ctrl_handler);
-	v4l2_device_unregister(&dev->v4l2_dev);
-
-free_dev:
-	kfree(dev);
-
-cleanup_gdev:
-	for (i = 0; i < camera; i++) {
-		bcm2835_cleanup_instance(gdev[i]);
-		gdev[i] = NULL;
-	}
-
-cleanup_mmal:
-	vchiq_mmal_finalise(instance);
-
-	return ret;
-}
-
-static void bcm2835_mmal_remove(struct vchiq_device *device)
-{
-	int camera;
-	struct vchiq_mmal_instance *instance = gdev[0]->instance;
-
-	for (camera = 0; camera < MAX_BCM2835_CAMERAS; camera++) {
-		bcm2835_cleanup_instance(gdev[camera]);
-		gdev[camera] = NULL;
-	}
-	vchiq_mmal_finalise(instance);
-}
-
-static const struct vchiq_device_id device_id_table[] = {
-	{ .name = "bcm2835-camera" },
-	{}
-};
-MODULE_DEVICE_TABLE(vchiq, device_id_table);
-
-static struct vchiq_driver bcm2835_camera_driver = {
-	.probe		= bcm2835_mmal_probe,
-	.remove		= bcm2835_mmal_remove,
-	.id_table	= device_id_table,
-	.driver		= {
-		.name	= "bcm2835-camera",
-	},
-};
-
-module_vchiq_driver(bcm2835_camera_driver)
-
-MODULE_DESCRIPTION("Broadcom 2835 MMAL video capture");
-MODULE_AUTHOR("Vincent Sanders");
-MODULE_LICENSE("GPL");
diff --git a/drivers/staging/vc04_services/bcm2835-camera/bcm2835-camera.h b/drivers/staging/vc04_services/bcm2835-camera/bcm2835-camera.h
deleted file mode 100644
index 0f0c6f7a376434ad5458910f29d485bab223adb5..0000000000000000000000000000000000000000
--- a/drivers/staging/vc04_services/bcm2835-camera/bcm2835-camera.h
+++ /dev/null
@@ -1,142 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Broadcom BCM2835 V4L2 driver
- *
- * Copyright Â© 2013 Raspberry Pi (Trading) Ltd.
- *
- * Authors: Vincent Sanders @ Collabora
- *          Dave Stevenson @ Broadcom
- *		(now dave.stevenson@raspberrypi.org)
- *          Simon Mellor @ Broadcom
- *          Luke Diamand @ Broadcom
- *
- * core driver device
- */
-
-#define V4L2_CTRL_COUNT 29 /* number of v4l controls */
-
-enum {
-	COMP_CAMERA = 0,
-	COMP_PREVIEW,
-	COMP_IMAGE_ENCODE,
-	COMP_VIDEO_ENCODE,
-	COMP_COUNT
-};
-
-enum {
-	CAM_PORT_PREVIEW = 0,
-	CAM_PORT_VIDEO,
-	CAM_PORT_CAPTURE,
-	CAM_PORT_COUNT
-};
-
-extern int bcm2835_v4l2_debug;
-
-struct bcm2835_mmal_dev {
-	/* v4l2 devices */
-	struct v4l2_device v4l2_dev;
-	struct video_device vdev;
-	struct mutex mutex;
-
-	/* controls */
-	struct v4l2_ctrl_handler ctrl_handler;
-	struct v4l2_ctrl *ctrls[V4L2_CTRL_COUNT];
-	enum v4l2_scene_mode scene_mode;
-	struct mmal_colourfx colourfx;
-	int hflip;
-	int vflip;
-	int red_gain;
-	int blue_gain;
-	enum mmal_parameter_exposuremode exposure_mode_user;
-	enum v4l2_exposure_auto_type exposure_mode_v4l2_user;
-	/* active exposure mode may differ if selected via a scene mode */
-	enum mmal_parameter_exposuremode exposure_mode_active;
-	enum mmal_parameter_exposuremeteringmode metering_mode;
-	unsigned int manual_shutter_speed;
-	bool exp_auto_priority;
-	bool manual_iso_enabled;
-	u32 iso;
-
-	/* allocated mmal instance and components */
-	struct vchiq_mmal_instance *instance;
-	struct vchiq_mmal_component *component[COMP_COUNT];
-	int camera_use_count;
-
-	struct v4l2_window overlay;
-
-	struct {
-		unsigned int width;  /* width */
-		unsigned int height;  /* height */
-		unsigned int stride;  /* stride */
-		unsigned int buffersize; /* buffer size with padding */
-		struct mmal_fmt *fmt;
-		struct v4l2_fract timeperframe;
-
-		/* H264 encode bitrate */
-		int encode_bitrate;
-		/* H264 bitrate mode. CBR/VBR */
-		int encode_bitrate_mode;
-		/* H264 profile */
-		enum v4l2_mpeg_video_h264_profile enc_profile;
-		/* H264 level */
-		enum v4l2_mpeg_video_h264_level enc_level;
-		/* JPEG Q-factor */
-		int q_factor;
-
-		struct vb2_queue vb_vidq;
-
-		/* VC start timestamp for streaming */
-		s64 vc_start_timestamp;
-		/* Kernel start timestamp for streaming */
-		ktime_t kernel_start_ts;
-		/* Sequence number of last buffer */
-		u32 sequence;
-
-		struct vchiq_mmal_port *port; /* port being used for capture */
-		/* camera port being used for capture */
-		struct vchiq_mmal_port *camera_port;
-		/* component being used for encode */
-		struct vchiq_mmal_component *encode_component;
-		/* number of frames remaining which driver should capture */
-		unsigned int frame_count;
-		/* last frame completion */
-		struct completion frame_cmplt;
-
-	} capture;
-
-	unsigned int camera_num;
-	unsigned int max_width;
-	unsigned int max_height;
-	unsigned int rgb_bgr_swapped;
-};
-
-int bcm2835_mmal_init_controls(struct bcm2835_mmal_dev *dev, struct v4l2_ctrl_handler *hdl);
-
-int bcm2835_mmal_set_all_camera_controls(struct bcm2835_mmal_dev *dev);
-int set_framerate_params(struct bcm2835_mmal_dev *dev);
-
-/* Debug helpers */
-
-#define v4l2_dump_pix_format(level, debug, dev, pix_fmt, desc)	\
-{	\
-	v4l2_dbg(level, debug, dev,	\
-"%s: w %u h %u field %u pfmt 0x%x bpl %u sz_img %u colorspace 0x%x priv %u\n", \
-		desc,	\
-		(pix_fmt)->width, (pix_fmt)->height, (pix_fmt)->field,	\
-		(pix_fmt)->pixelformat, (pix_fmt)->bytesperline,	\
-		(pix_fmt)->sizeimage, (pix_fmt)->colorspace, (pix_fmt)->priv); \
-}
-
-#define v4l2_dump_win_format(level, debug, dev, win_fmt, desc)	\
-{	\
-	v4l2_dbg(level, debug, dev,	\
-"%s: w %u h %u l %u t %u  field %u chromakey %06X clip %p " \
-"clipcount %u bitmap %p\n", \
-		desc,	\
-		(win_fmt)->w.width, (win_fmt)->w.height, \
-		(win_fmt)->w.left, (win_fmt)->w.top, \
-		(win_fmt)->field,	\
-		(win_fmt)->chromakey,	\
-		(win_fmt)->clips, (win_fmt)->clipcount,	\
-		(win_fmt)->bitmap); \
-}
diff --git a/drivers/staging/vc04_services/bcm2835-camera/controls.c b/drivers/staging/vc04_services/bcm2835-camera/controls.c
deleted file mode 100644
index e670226f1edf77a13e303e13dae783922175311b..0000000000000000000000000000000000000000
--- a/drivers/staging/vc04_services/bcm2835-camera/controls.c
+++ /dev/null
@@ -1,1399 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Broadcom BCM2835 V4L2 driver
- *
- * Copyright Â© 2013 Raspberry Pi (Trading) Ltd.
- *
- * Authors: Vincent Sanders @ Collabora
- *          Dave Stevenson @ Broadcom
- *		(now dave.stevenson@raspberrypi.org)
- *          Simon Mellor @ Broadcom
- *          Luke Diamand @ Broadcom
- */
-
-#include <linux/errno.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/slab.h>
-#include <media/videobuf2-vmalloc.h>
-#include <media/v4l2-device.h>
-#include <media/v4l2-ioctl.h>
-#include <media/v4l2-ctrls.h>
-#include <media/v4l2-fh.h>
-#include <media/v4l2-event.h>
-#include <media/v4l2-common.h>
-
-#include "../vchiq-mmal/mmal-common.h"
-#include "../vchiq-mmal/mmal-vchiq.h"
-#include "../vchiq-mmal/mmal-parameters.h"
-#include "bcm2835-camera.h"
-
-/* The supported V4L2_CID_AUTO_EXPOSURE_BIAS values are from -4.0 to +4.0.
- * MMAL values are in 1/6th increments so the MMAL range is -24 to +24.
- * V4L2 docs say value "is expressed in terms of EV, drivers should interpret
- * the values as 0.001 EV units, where the value 1000 stands for +1 EV."
- * V4L2 is limited to a max of 32 values in a menu, so count in 1/3rds from
- * -4 to +4
- */
-static const s64 ev_bias_qmenu[] = {
-	-4000, -3667, -3333,
-	-3000, -2667, -2333,
-	-2000, -1667, -1333,
-	-1000,  -667,  -333,
-	    0,   333,   667,
-	 1000,  1333,  1667,
-	 2000,  2333,  2667,
-	 3000,  3333,  3667,
-	 4000
-};
-
-/* Supported ISO values (*1000)
- * ISOO = auto ISO
- */
-static const s64 iso_qmenu[] = {
-	0, 100000, 200000, 400000, 800000,
-};
-
-static const u32 iso_values[] = {
-	0, 100, 200, 400, 800,
-};
-
-enum bcm2835_mmal_ctrl_type {
-	MMAL_CONTROL_TYPE_STD,
-	MMAL_CONTROL_TYPE_STD_MENU,
-	MMAL_CONTROL_TYPE_INT_MENU,
-	MMAL_CONTROL_TYPE_CLUSTER, /* special cluster entry */
-};
-
-struct bcm2835_mmal_v4l2_ctrl {
-	u32 id; /* v4l2 control identifier */
-	enum bcm2835_mmal_ctrl_type type;
-	/* control minimum value or
-	 * mask for MMAL_CONTROL_TYPE_STD_MENU
-	 */
-	s64 min;
-	s64 max; /* maximum value of control */
-	s64 def;  /* default value of control */
-	u64 step; /* step size of the control */
-	const s64 *imenu; /* integer menu array */
-	u32 mmal_id; /* mmal parameter id */
-	int (*setter)(struct bcm2835_mmal_dev *dev, struct v4l2_ctrl *ctrl,
-		      const struct bcm2835_mmal_v4l2_ctrl *mmal_ctrl);
-};
-
-struct v4l2_to_mmal_effects_setting {
-	u32 v4l2_effect;
-	u32 mmal_effect;
-	s32 col_fx_enable;
-	s32 col_fx_fixed_cbcr;
-	u32 u;
-	u32 v;
-	u32 num_effect_params;
-	u32 effect_params[MMAL_MAX_IMAGEFX_PARAMETERS];
-};
-
-static const struct v4l2_to_mmal_effects_setting
-	v4l2_to_mmal_effects_values[] = {
-	{  V4L2_COLORFX_NONE,         MMAL_PARAM_IMAGEFX_NONE,
-		0,   0,    0,    0,   0, {0, 0, 0, 0, 0} },
-	{  V4L2_COLORFX_BW,           MMAL_PARAM_IMAGEFX_NONE,
-		1,   0,    128,  128, 0, {0, 0, 0, 0, 0} },
-	{  V4L2_COLORFX_SEPIA,        MMAL_PARAM_IMAGEFX_NONE,
-		1,   0,    87,   151, 0, {0, 0, 0, 0, 0} },
-	{  V4L2_COLORFX_NEGATIVE,     MMAL_PARAM_IMAGEFX_NEGATIVE,
-		0,   0,    0,    0,   0, {0, 0, 0, 0, 0} },
-	{  V4L2_COLORFX_EMBOSS,       MMAL_PARAM_IMAGEFX_EMBOSS,
-		0,   0,    0,    0,   0, {0, 0, 0, 0, 0} },
-	{  V4L2_COLORFX_SKETCH,       MMAL_PARAM_IMAGEFX_SKETCH,
-		0,   0,    0,    0,   0, {0, 0, 0, 0, 0} },
-	{  V4L2_COLORFX_SKY_BLUE,     MMAL_PARAM_IMAGEFX_PASTEL,
-		0,   0,    0,    0,   0, {0, 0, 0, 0, 0} },
-	{  V4L2_COLORFX_GRASS_GREEN,  MMAL_PARAM_IMAGEFX_WATERCOLOUR,
-		0,   0,    0,    0,   0, {0, 0, 0, 0, 0} },
-	{  V4L2_COLORFX_SKIN_WHITEN,  MMAL_PARAM_IMAGEFX_WASHEDOUT,
-		0,   0,    0,    0,   0, {0, 0, 0, 0, 0} },
-	{  V4L2_COLORFX_VIVID,        MMAL_PARAM_IMAGEFX_SATURATION,
-		0,   0,    0,    0,   0, {0, 0, 0, 0, 0} },
-	{  V4L2_COLORFX_AQUA,         MMAL_PARAM_IMAGEFX_NONE,
-		1,   0,    171,  121, 0, {0, 0, 0, 0, 0} },
-	{  V4L2_COLORFX_ART_FREEZE,   MMAL_PARAM_IMAGEFX_HATCH,
-		0,   0,    0,    0,   0, {0, 0, 0, 0, 0} },
-	{  V4L2_COLORFX_SILHOUETTE,   MMAL_PARAM_IMAGEFX_FILM,
-		0,   0,    0,    0,   0, {0, 0, 0, 0, 0} },
-	{  V4L2_COLORFX_SOLARIZATION, MMAL_PARAM_IMAGEFX_SOLARIZE,
-		0,   0,    0,    0,   5, {1, 128, 160, 160, 48} },
-	{  V4L2_COLORFX_ANTIQUE,      MMAL_PARAM_IMAGEFX_COLOURBALANCE,
-		0,   0,    0,    0,   3, {108, 274, 238, 0, 0} },
-	{  V4L2_COLORFX_SET_CBCR,     MMAL_PARAM_IMAGEFX_NONE,
-		1,   1,    0,    0,   0, {0, 0, 0, 0, 0} }
-};
-
-struct v4l2_mmal_scene_config {
-	enum v4l2_scene_mode v4l2_scene;
-	enum mmal_parameter_exposuremode exposure_mode;
-	enum mmal_parameter_exposuremeteringmode metering_mode;
-};
-
-static const struct v4l2_mmal_scene_config scene_configs[] = {
-	/* V4L2_SCENE_MODE_NONE automatically added */
-	{
-		V4L2_SCENE_MODE_NIGHT,
-		MMAL_PARAM_EXPOSUREMODE_NIGHT,
-		MMAL_PARAM_EXPOSUREMETERINGMODE_AVERAGE
-	},
-	{
-		V4L2_SCENE_MODE_SPORTS,
-		MMAL_PARAM_EXPOSUREMODE_SPORTS,
-		MMAL_PARAM_EXPOSUREMETERINGMODE_AVERAGE
-	},
-};
-
-/* control handlers*/
-
-static int ctrl_set_rational(struct bcm2835_mmal_dev *dev,
-			     struct v4l2_ctrl *ctrl,
-			     const struct bcm2835_mmal_v4l2_ctrl *mmal_ctrl)
-{
-	struct s32_fract rational_value;
-	struct vchiq_mmal_port *control;
-
-	control = &dev->component[COMP_CAMERA]->control;
-
-	rational_value.numerator = ctrl->val;
-	rational_value.denominator = 100;
-
-	return vchiq_mmal_port_parameter_set(dev->instance, control,
-					     mmal_ctrl->mmal_id,
-					     &rational_value,
-					     sizeof(rational_value));
-}
-
-static int ctrl_set_value(struct bcm2835_mmal_dev *dev,
-			  struct v4l2_ctrl *ctrl,
-			  const struct bcm2835_mmal_v4l2_ctrl *mmal_ctrl)
-{
-	u32 u32_value;
-	struct vchiq_mmal_port *control;
-
-	control = &dev->component[COMP_CAMERA]->control;
-
-	u32_value = ctrl->val;
-
-	return vchiq_mmal_port_parameter_set(dev->instance, control,
-					     mmal_ctrl->mmal_id,
-					     &u32_value, sizeof(u32_value));
-}
-
-static int ctrl_set_iso(struct bcm2835_mmal_dev *dev,
-			struct v4l2_ctrl *ctrl,
-			const struct bcm2835_mmal_v4l2_ctrl *mmal_ctrl)
-{
-	u32 u32_value;
-	struct vchiq_mmal_port *control;
-
-	if (ctrl->val > mmal_ctrl->max || ctrl->val < mmal_ctrl->min)
-		return 1;
-
-	if (ctrl->id == V4L2_CID_ISO_SENSITIVITY)
-		dev->iso = iso_values[ctrl->val];
-	else if (ctrl->id == V4L2_CID_ISO_SENSITIVITY_AUTO)
-		dev->manual_iso_enabled =
-				(ctrl->val == V4L2_ISO_SENSITIVITY_MANUAL);
-
-	control = &dev->component[COMP_CAMERA]->control;
-
-	if (dev->manual_iso_enabled)
-		u32_value = dev->iso;
-	else
-		u32_value = 0;
-
-	return vchiq_mmal_port_parameter_set(dev->instance, control,
-					     MMAL_PARAMETER_ISO,
-					     &u32_value, sizeof(u32_value));
-}
-
-static int ctrl_set_value_ev(struct bcm2835_mmal_dev *dev,
-			     struct v4l2_ctrl *ctrl,
-			     const struct bcm2835_mmal_v4l2_ctrl *mmal_ctrl)
-{
-	s32 s32_value;
-	struct vchiq_mmal_port *control;
-
-	control = &dev->component[COMP_CAMERA]->control;
-
-	s32_value = (ctrl->val - 12) * 2;	/* Convert from index to 1/6ths */
-
-	return vchiq_mmal_port_parameter_set(dev->instance, control,
-					     mmal_ctrl->mmal_id,
-					     &s32_value, sizeof(s32_value));
-}
-
-static int ctrl_set_rotate(struct bcm2835_mmal_dev *dev,
-			   struct v4l2_ctrl *ctrl,
-			   const struct bcm2835_mmal_v4l2_ctrl *mmal_ctrl)
-{
-	int ret;
-	u32 u32_value;
-	struct vchiq_mmal_component *camera;
-
-	camera = dev->component[COMP_CAMERA];
-
-	u32_value = ((ctrl->val % 360) / 90) * 90;
-
-	ret = vchiq_mmal_port_parameter_set(dev->instance, &camera->output[0],
-					    mmal_ctrl->mmal_id,
-					    &u32_value, sizeof(u32_value));
-	if (ret < 0)
-		return ret;
-
-	ret = vchiq_mmal_port_parameter_set(dev->instance, &camera->output[1],
-					    mmal_ctrl->mmal_id,
-					    &u32_value, sizeof(u32_value));
-	if (ret < 0)
-		return ret;
-
-	return vchiq_mmal_port_parameter_set(dev->instance, &camera->output[2],
-					    mmal_ctrl->mmal_id,
-					    &u32_value, sizeof(u32_value));
-}
-
-static int ctrl_set_flip(struct bcm2835_mmal_dev *dev,
-			 struct v4l2_ctrl *ctrl,
-			 const struct bcm2835_mmal_v4l2_ctrl *mmal_ctrl)
-{
-	int ret;
-	u32 u32_value;
-	struct vchiq_mmal_component *camera;
-
-	if (ctrl->id == V4L2_CID_HFLIP)
-		dev->hflip = ctrl->val;
-	else
-		dev->vflip = ctrl->val;
-
-	camera = dev->component[COMP_CAMERA];
-
-	if (dev->hflip && dev->vflip)
-		u32_value = MMAL_PARAM_MIRROR_BOTH;
-	else if (dev->hflip)
-		u32_value = MMAL_PARAM_MIRROR_HORIZONTAL;
-	else if (dev->vflip)
-		u32_value = MMAL_PARAM_MIRROR_VERTICAL;
-	else
-		u32_value = MMAL_PARAM_MIRROR_NONE;
-
-	ret = vchiq_mmal_port_parameter_set(dev->instance, &camera->output[0],
-					    mmal_ctrl->mmal_id,
-					    &u32_value, sizeof(u32_value));
-	if (ret < 0)
-		return ret;
-
-	ret = vchiq_mmal_port_parameter_set(dev->instance, &camera->output[1],
-					    mmal_ctrl->mmal_id,
-					    &u32_value, sizeof(u32_value));
-	if (ret < 0)
-		return ret;
-
-	return vchiq_mmal_port_parameter_set(dev->instance, &camera->output[2],
-					    mmal_ctrl->mmal_id,
-					    &u32_value, sizeof(u32_value));
-}
-
-static int ctrl_set_exposure(struct bcm2835_mmal_dev *dev,
-			     struct v4l2_ctrl *ctrl,
-			     const struct bcm2835_mmal_v4l2_ctrl *mmal_ctrl)
-{
-	enum mmal_parameter_exposuremode exp_mode = dev->exposure_mode_user;
-	u32 shutter_speed = 0;
-	struct vchiq_mmal_port *control;
-	int ret = 0;
-
-	control = &dev->component[COMP_CAMERA]->control;
-
-	if (mmal_ctrl->mmal_id == MMAL_PARAMETER_SHUTTER_SPEED)	{
-		/* V4L2 is in 100usec increments.
-		 * MMAL is 1usec.
-		 */
-		dev->manual_shutter_speed = ctrl->val * 100;
-	} else if (mmal_ctrl->mmal_id == MMAL_PARAMETER_EXPOSURE_MODE) {
-		switch (ctrl->val) {
-		case V4L2_EXPOSURE_AUTO:
-			exp_mode = MMAL_PARAM_EXPOSUREMODE_AUTO;
-			break;
-
-		case V4L2_EXPOSURE_MANUAL:
-			exp_mode = MMAL_PARAM_EXPOSUREMODE_OFF;
-			break;
-		}
-		dev->exposure_mode_user = exp_mode;
-		dev->exposure_mode_v4l2_user = ctrl->val;
-	} else if (mmal_ctrl->id == V4L2_CID_EXPOSURE_AUTO_PRIORITY) {
-		dev->exp_auto_priority = ctrl->val;
-	}
-
-	if (dev->scene_mode == V4L2_SCENE_MODE_NONE) {
-		if (exp_mode == MMAL_PARAM_EXPOSUREMODE_OFF)
-			shutter_speed = dev->manual_shutter_speed;
-
-		ret = vchiq_mmal_port_parameter_set(dev->instance,
-						    control,
-						    MMAL_PARAMETER_SHUTTER_SPEED,
-						    &shutter_speed,
-						    sizeof(shutter_speed));
-		ret += vchiq_mmal_port_parameter_set(dev->instance,
-						     control,
-						     MMAL_PARAMETER_EXPOSURE_MODE,
-						     &exp_mode,
-						     sizeof(u32));
-		dev->exposure_mode_active = exp_mode;
-	}
-	/* exposure_dynamic_framerate (V4L2_CID_EXPOSURE_AUTO_PRIORITY) should
-	 * always apply irrespective of scene mode.
-	 */
-	ret += set_framerate_params(dev);
-
-	return ret;
-}
-
-static int ctrl_set_metering_mode(struct bcm2835_mmal_dev *dev,
-				  struct v4l2_ctrl *ctrl,
-				  const struct bcm2835_mmal_v4l2_ctrl *mmal_ctrl)
-{
-	switch (ctrl->val) {
-	case V4L2_EXPOSURE_METERING_AVERAGE:
-		dev->metering_mode = MMAL_PARAM_EXPOSUREMETERINGMODE_AVERAGE;
-		break;
-
-	case V4L2_EXPOSURE_METERING_CENTER_WEIGHTED:
-		dev->metering_mode = MMAL_PARAM_EXPOSUREMETERINGMODE_BACKLIT;
-		break;
-
-	case V4L2_EXPOSURE_METERING_SPOT:
-		dev->metering_mode = MMAL_PARAM_EXPOSUREMETERINGMODE_SPOT;
-		break;
-
-	case V4L2_EXPOSURE_METERING_MATRIX:
-		dev->metering_mode = MMAL_PARAM_EXPOSUREMETERINGMODE_MATRIX;
-		break;
-	}
-
-	if (dev->scene_mode == V4L2_SCENE_MODE_NONE) {
-		struct vchiq_mmal_port *control;
-		u32 u32_value = dev->metering_mode;
-
-		control = &dev->component[COMP_CAMERA]->control;
-
-		return vchiq_mmal_port_parameter_set(dev->instance, control,
-					     mmal_ctrl->mmal_id,
-					     &u32_value, sizeof(u32_value));
-	} else {
-		return 0;
-	}
-}
-
-static int ctrl_set_flicker_avoidance(struct bcm2835_mmal_dev *dev,
-				      struct v4l2_ctrl *ctrl,
-				      const struct bcm2835_mmal_v4l2_ctrl *mmal_ctrl)
-{
-	u32 u32_value;
-	struct vchiq_mmal_port *control;
-
-	control = &dev->component[COMP_CAMERA]->control;
-
-	switch (ctrl->val) {
-	case V4L2_CID_POWER_LINE_FREQUENCY_DISABLED:
-		u32_value = MMAL_PARAM_FLICKERAVOID_OFF;
-		break;
-	case V4L2_CID_POWER_LINE_FREQUENCY_50HZ:
-		u32_value = MMAL_PARAM_FLICKERAVOID_50HZ;
-		break;
-	case V4L2_CID_POWER_LINE_FREQUENCY_60HZ:
-		u32_value = MMAL_PARAM_FLICKERAVOID_60HZ;
-		break;
-	case V4L2_CID_POWER_LINE_FREQUENCY_AUTO:
-		u32_value = MMAL_PARAM_FLICKERAVOID_AUTO;
-		break;
-	}
-
-	return vchiq_mmal_port_parameter_set(dev->instance, control,
-					     mmal_ctrl->mmal_id,
-					     &u32_value, sizeof(u32_value));
-}
-
-static int ctrl_set_awb_mode(struct bcm2835_mmal_dev *dev,
-			     struct v4l2_ctrl *ctrl,
-			     const struct bcm2835_mmal_v4l2_ctrl *mmal_ctrl)
-{
-	u32 u32_value;
-	struct vchiq_mmal_port *control;
-
-	control = &dev->component[COMP_CAMERA]->control;
-
-	switch (ctrl->val) {
-	case V4L2_WHITE_BALANCE_MANUAL:
-		u32_value = MMAL_PARAM_AWBMODE_OFF;
-		break;
-
-	case V4L2_WHITE_BALANCE_AUTO:
-		u32_value = MMAL_PARAM_AWBMODE_AUTO;
-		break;
-
-	case V4L2_WHITE_BALANCE_INCANDESCENT:
-		u32_value = MMAL_PARAM_AWBMODE_INCANDESCENT;
-		break;
-
-	case V4L2_WHITE_BALANCE_FLUORESCENT:
-		u32_value = MMAL_PARAM_AWBMODE_FLUORESCENT;
-		break;
-
-	case V4L2_WHITE_BALANCE_FLUORESCENT_H:
-		u32_value = MMAL_PARAM_AWBMODE_TUNGSTEN;
-		break;
-
-	case V4L2_WHITE_BALANCE_HORIZON:
-		u32_value = MMAL_PARAM_AWBMODE_HORIZON;
-		break;
-
-	case V4L2_WHITE_BALANCE_DAYLIGHT:
-		u32_value = MMAL_PARAM_AWBMODE_SUNLIGHT;
-		break;
-
-	case V4L2_WHITE_BALANCE_FLASH:
-		u32_value = MMAL_PARAM_AWBMODE_FLASH;
-		break;
-
-	case V4L2_WHITE_BALANCE_CLOUDY:
-		u32_value = MMAL_PARAM_AWBMODE_CLOUDY;
-		break;
-
-	case V4L2_WHITE_BALANCE_SHADE:
-		u32_value = MMAL_PARAM_AWBMODE_SHADE;
-		break;
-	}
-
-	return vchiq_mmal_port_parameter_set(dev->instance, control,
-					     mmal_ctrl->mmal_id,
-					     &u32_value, sizeof(u32_value));
-}
-
-static int ctrl_set_awb_gains(struct bcm2835_mmal_dev *dev,
-			      struct v4l2_ctrl *ctrl,
-			      const struct bcm2835_mmal_v4l2_ctrl *mmal_ctrl)
-{
-	struct vchiq_mmal_port *control;
-	struct mmal_parameter_awbgains gains;
-
-	control = &dev->component[COMP_CAMERA]->control;
-
-	if (ctrl->id == V4L2_CID_RED_BALANCE)
-		dev->red_gain = ctrl->val;
-	else if (ctrl->id == V4L2_CID_BLUE_BALANCE)
-		dev->blue_gain = ctrl->val;
-
-	gains.r_gain.numerator = dev->red_gain;
-	gains.r_gain.denominator = 1000;
-	gains.b_gain.numerator = dev->blue_gain;
-	gains.b_gain.denominator = 1000;
-
-	return vchiq_mmal_port_parameter_set(dev->instance, control,
-					     mmal_ctrl->mmal_id,
-					     &gains, sizeof(gains));
-}
-
-static int ctrl_set_image_effect(struct bcm2835_mmal_dev *dev,
-				 struct v4l2_ctrl *ctrl,
-				 const struct bcm2835_mmal_v4l2_ctrl *mmal_ctrl)
-{
-	int ret = -EINVAL;
-	int i, j;
-	struct vchiq_mmal_port *control;
-	struct mmal_parameter_imagefx_parameters imagefx;
-
-	for (i = 0; i < ARRAY_SIZE(v4l2_to_mmal_effects_values); i++) {
-		if (ctrl->val != v4l2_to_mmal_effects_values[i].v4l2_effect)
-			continue;
-
-		imagefx.effect =
-			v4l2_to_mmal_effects_values[i].mmal_effect;
-		imagefx.num_effect_params =
-			v4l2_to_mmal_effects_values[i].num_effect_params;
-
-		if (imagefx.num_effect_params > MMAL_MAX_IMAGEFX_PARAMETERS)
-			imagefx.num_effect_params = MMAL_MAX_IMAGEFX_PARAMETERS;
-
-		for (j = 0; j < imagefx.num_effect_params; j++)
-			imagefx.effect_parameter[j] =
-				v4l2_to_mmal_effects_values[i].effect_params[j];
-
-		dev->colourfx.enable =
-			v4l2_to_mmal_effects_values[i].col_fx_enable;
-		if (!v4l2_to_mmal_effects_values[i].col_fx_fixed_cbcr) {
-			dev->colourfx.u = v4l2_to_mmal_effects_values[i].u;
-			dev->colourfx.v = v4l2_to_mmal_effects_values[i].v;
-		}
-
-		control = &dev->component[COMP_CAMERA]->control;
-
-		ret = vchiq_mmal_port_parameter_set(dev->instance, control,
-						    MMAL_PARAMETER_IMAGE_EFFECT_PARAMETERS,
-						    &imagefx, sizeof(imagefx));
-		if (ret)
-			goto exit;
-
-		ret = vchiq_mmal_port_parameter_set(dev->instance, control,
-						    MMAL_PARAMETER_COLOUR_EFFECT,
-						    &dev->colourfx, sizeof(dev->colourfx));
-	}
-
-exit:
-	v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-		 "mmal_ctrl:%p ctrl id:0x%x ctrl val:%d imagefx:0x%x color_effect:%s u:%d v:%d ret %d(%d)\n",
-				mmal_ctrl, ctrl->id, ctrl->val, imagefx.effect,
-				dev->colourfx.enable ? "true" : "false",
-				dev->colourfx.u, dev->colourfx.v,
-				ret, (ret == 0 ? 0 : -EINVAL));
-	return (ret == 0 ? 0 : -EINVAL);
-}
-
-static int ctrl_set_colfx(struct bcm2835_mmal_dev *dev,
-			  struct v4l2_ctrl *ctrl,
-			  const struct bcm2835_mmal_v4l2_ctrl *mmal_ctrl)
-{
-	int ret;
-	struct vchiq_mmal_port *control;
-
-	control = &dev->component[COMP_CAMERA]->control;
-
-	dev->colourfx.u = (ctrl->val & 0xff00) >> 8;
-	dev->colourfx.v = ctrl->val & 0xff;
-
-	ret = vchiq_mmal_port_parameter_set(dev->instance, control,
-					    MMAL_PARAMETER_COLOUR_EFFECT,
-					    &dev->colourfx,
-					    sizeof(dev->colourfx));
-
-	v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-		 "%s: After: mmal_ctrl:%p ctrl id:0x%x ctrl val:%d ret %d(%d)\n",
-			__func__, mmal_ctrl, ctrl->id, ctrl->val, ret,
-			(ret == 0 ? 0 : -EINVAL));
-	return (ret == 0 ? 0 : -EINVAL);
-}
-
-static int ctrl_set_bitrate(struct bcm2835_mmal_dev *dev,
-			    struct v4l2_ctrl *ctrl,
-			    const struct bcm2835_mmal_v4l2_ctrl *mmal_ctrl)
-{
-	int ret;
-	struct vchiq_mmal_port *encoder_out;
-
-	dev->capture.encode_bitrate = ctrl->val;
-
-	encoder_out = &dev->component[COMP_VIDEO_ENCODE]->output[0];
-
-	ret = vchiq_mmal_port_parameter_set(dev->instance, encoder_out,
-					    mmal_ctrl->mmal_id, &ctrl->val,
-					    sizeof(ctrl->val));
-
-	v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-		 "%s: After: mmal_ctrl:%p ctrl id:0x%x ctrl val:%d ret %d(%d)\n",
-		 __func__, mmal_ctrl, ctrl->id, ctrl->val, ret,
-		 (ret == 0 ? 0 : -EINVAL));
-
-	/*
-	 * Older firmware versions (pre July 2019) have a bug in handling
-	 * MMAL_PARAMETER_VIDEO_BIT_RATE that result in the call
-	 * returning -MMAL_MSG_STATUS_EINVAL. So ignore errors from this call.
-	 */
-	return 0;
-}
-
-static int ctrl_set_bitrate_mode(struct bcm2835_mmal_dev *dev,
-				 struct v4l2_ctrl *ctrl,
-				 const struct bcm2835_mmal_v4l2_ctrl *mmal_ctrl)
-{
-	u32 bitrate_mode;
-	struct vchiq_mmal_port *encoder_out;
-
-	encoder_out = &dev->component[COMP_VIDEO_ENCODE]->output[0];
-
-	dev->capture.encode_bitrate_mode = ctrl->val;
-	switch (ctrl->val) {
-	default:
-	case V4L2_MPEG_VIDEO_BITRATE_MODE_VBR:
-		bitrate_mode = MMAL_VIDEO_RATECONTROL_VARIABLE;
-		break;
-	case V4L2_MPEG_VIDEO_BITRATE_MODE_CBR:
-		bitrate_mode = MMAL_VIDEO_RATECONTROL_CONSTANT;
-		break;
-	}
-
-	vchiq_mmal_port_parameter_set(dev->instance, encoder_out,
-				      mmal_ctrl->mmal_id,
-					     &bitrate_mode,
-					     sizeof(bitrate_mode));
-	return 0;
-}
-
-static int ctrl_set_image_encode_output(struct bcm2835_mmal_dev *dev,
-					struct v4l2_ctrl *ctrl,
-					const struct bcm2835_mmal_v4l2_ctrl *mmal_ctrl)
-{
-	u32 u32_value;
-	struct vchiq_mmal_port *jpeg_out;
-
-	jpeg_out = &dev->component[COMP_IMAGE_ENCODE]->output[0];
-
-	u32_value = ctrl->val;
-
-	return vchiq_mmal_port_parameter_set(dev->instance, jpeg_out,
-					     mmal_ctrl->mmal_id,
-					     &u32_value, sizeof(u32_value));
-}
-
-static int ctrl_set_video_encode_param_output(struct bcm2835_mmal_dev *dev,
-					      struct v4l2_ctrl *ctrl,
-					      const struct bcm2835_mmal_v4l2_ctrl *mmal_ctrl)
-{
-	u32 u32_value;
-	struct vchiq_mmal_port *vid_enc_ctl;
-
-	vid_enc_ctl = &dev->component[COMP_VIDEO_ENCODE]->output[0];
-
-	u32_value = ctrl->val;
-
-	return vchiq_mmal_port_parameter_set(dev->instance, vid_enc_ctl,
-					     mmal_ctrl->mmal_id,
-					     &u32_value, sizeof(u32_value));
-}
-
-static int ctrl_set_video_encode_profile_level(struct bcm2835_mmal_dev *dev,
-					       struct v4l2_ctrl *ctrl,
-					       const struct bcm2835_mmal_v4l2_ctrl *mmal_ctrl)
-{
-	struct mmal_parameter_video_profile param;
-	int ret = 0;
-
-	if (ctrl->id == V4L2_CID_MPEG_VIDEO_H264_PROFILE) {
-		switch (ctrl->val) {
-		case V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE:
-		case V4L2_MPEG_VIDEO_H264_PROFILE_CONSTRAINED_BASELINE:
-		case V4L2_MPEG_VIDEO_H264_PROFILE_MAIN:
-		case V4L2_MPEG_VIDEO_H264_PROFILE_HIGH:
-			dev->capture.enc_profile = ctrl->val;
-			break;
-		default:
-			ret = -EINVAL;
-			break;
-		}
-	} else if (ctrl->id == V4L2_CID_MPEG_VIDEO_H264_LEVEL) {
-		switch (ctrl->val) {
-		case V4L2_MPEG_VIDEO_H264_LEVEL_1_0:
-		case V4L2_MPEG_VIDEO_H264_LEVEL_1B:
-		case V4L2_MPEG_VIDEO_H264_LEVEL_1_1:
-		case V4L2_MPEG_VIDEO_H264_LEVEL_1_2:
-		case V4L2_MPEG_VIDEO_H264_LEVEL_1_3:
-		case V4L2_MPEG_VIDEO_H264_LEVEL_2_0:
-		case V4L2_MPEG_VIDEO_H264_LEVEL_2_1:
-		case V4L2_MPEG_VIDEO_H264_LEVEL_2_2:
-		case V4L2_MPEG_VIDEO_H264_LEVEL_3_0:
-		case V4L2_MPEG_VIDEO_H264_LEVEL_3_1:
-		case V4L2_MPEG_VIDEO_H264_LEVEL_3_2:
-		case V4L2_MPEG_VIDEO_H264_LEVEL_4_0:
-			dev->capture.enc_level = ctrl->val;
-			break;
-		default:
-			ret = -EINVAL;
-			break;
-		}
-	}
-
-	if (!ret) {
-		switch (dev->capture.enc_profile) {
-		case V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE:
-			param.profile = MMAL_VIDEO_PROFILE_H264_BASELINE;
-			break;
-		case V4L2_MPEG_VIDEO_H264_PROFILE_CONSTRAINED_BASELINE:
-			param.profile =
-				MMAL_VIDEO_PROFILE_H264_CONSTRAINED_BASELINE;
-			break;
-		case V4L2_MPEG_VIDEO_H264_PROFILE_MAIN:
-			param.profile = MMAL_VIDEO_PROFILE_H264_MAIN;
-			break;
-		case V4L2_MPEG_VIDEO_H264_PROFILE_HIGH:
-			param.profile = MMAL_VIDEO_PROFILE_H264_HIGH;
-			break;
-		default:
-			/* Should never get here */
-			break;
-		}
-
-		switch (dev->capture.enc_level) {
-		case V4L2_MPEG_VIDEO_H264_LEVEL_1_0:
-			param.level = MMAL_VIDEO_LEVEL_H264_1;
-			break;
-		case V4L2_MPEG_VIDEO_H264_LEVEL_1B:
-			param.level = MMAL_VIDEO_LEVEL_H264_1b;
-			break;
-		case V4L2_MPEG_VIDEO_H264_LEVEL_1_1:
-			param.level = MMAL_VIDEO_LEVEL_H264_11;
-			break;
-		case V4L2_MPEG_VIDEO_H264_LEVEL_1_2:
-			param.level = MMAL_VIDEO_LEVEL_H264_12;
-			break;
-		case V4L2_MPEG_VIDEO_H264_LEVEL_1_3:
-			param.level = MMAL_VIDEO_LEVEL_H264_13;
-			break;
-		case V4L2_MPEG_VIDEO_H264_LEVEL_2_0:
-			param.level = MMAL_VIDEO_LEVEL_H264_2;
-			break;
-		case V4L2_MPEG_VIDEO_H264_LEVEL_2_1:
-			param.level = MMAL_VIDEO_LEVEL_H264_21;
-			break;
-		case V4L2_MPEG_VIDEO_H264_LEVEL_2_2:
-			param.level = MMAL_VIDEO_LEVEL_H264_22;
-			break;
-		case V4L2_MPEG_VIDEO_H264_LEVEL_3_0:
-			param.level = MMAL_VIDEO_LEVEL_H264_3;
-			break;
-		case V4L2_MPEG_VIDEO_H264_LEVEL_3_1:
-			param.level = MMAL_VIDEO_LEVEL_H264_31;
-			break;
-		case V4L2_MPEG_VIDEO_H264_LEVEL_3_2:
-			param.level = MMAL_VIDEO_LEVEL_H264_32;
-			break;
-		case V4L2_MPEG_VIDEO_H264_LEVEL_4_0:
-			param.level = MMAL_VIDEO_LEVEL_H264_4;
-			break;
-		default:
-			/* Should never get here */
-			break;
-		}
-
-		ret = vchiq_mmal_port_parameter_set(dev->instance,
-						    &dev->component[COMP_VIDEO_ENCODE]->output[0],
-			mmal_ctrl->mmal_id,
-			&param, sizeof(param));
-	}
-	return ret;
-}
-
-static int ctrl_set_scene_mode(struct bcm2835_mmal_dev *dev,
-			       struct v4l2_ctrl *ctrl,
-			       const struct bcm2835_mmal_v4l2_ctrl *mmal_ctrl)
-{
-	int ret = 0;
-	int shutter_speed;
-	struct vchiq_mmal_port *control;
-
-	v4l2_dbg(0, bcm2835_v4l2_debug, &dev->v4l2_dev,
-		 "scene mode selected %d, was %d\n", ctrl->val,
-		 dev->scene_mode);
-	control = &dev->component[COMP_CAMERA]->control;
-
-	if (ctrl->val == dev->scene_mode)
-		return 0;
-
-	if (ctrl->val == V4L2_SCENE_MODE_NONE) {
-		/* Restore all user selections */
-		dev->scene_mode = V4L2_SCENE_MODE_NONE;
-
-		if (dev->exposure_mode_user == MMAL_PARAM_EXPOSUREMODE_OFF)
-			shutter_speed = dev->manual_shutter_speed;
-		else
-			shutter_speed = 0;
-
-		v4l2_dbg(0, bcm2835_v4l2_debug, &dev->v4l2_dev,
-			 "%s: scene mode none: shut_speed %d, exp_mode %d, metering %d\n",
-			 __func__, shutter_speed, dev->exposure_mode_user,
-			 dev->metering_mode);
-		ret = vchiq_mmal_port_parameter_set(dev->instance,
-						    control,
-						    MMAL_PARAMETER_SHUTTER_SPEED,
-						    &shutter_speed,
-						    sizeof(shutter_speed));
-		ret += vchiq_mmal_port_parameter_set(dev->instance,
-						     control,
-						     MMAL_PARAMETER_EXPOSURE_MODE,
-						     &dev->exposure_mode_user,
-						     sizeof(u32));
-		dev->exposure_mode_active = dev->exposure_mode_user;
-		ret += vchiq_mmal_port_parameter_set(dev->instance,
-						     control,
-						     MMAL_PARAMETER_EXP_METERING_MODE,
-						     &dev->metering_mode,
-						     sizeof(u32));
-		ret += set_framerate_params(dev);
-	} else {
-		/* Set up scene mode */
-		int i;
-		const struct v4l2_mmal_scene_config *scene = NULL;
-		int shutter_speed;
-		enum mmal_parameter_exposuremode exposure_mode;
-		enum mmal_parameter_exposuremeteringmode metering_mode;
-
-		for (i = 0; i < ARRAY_SIZE(scene_configs); i++) {
-			if (scene_configs[i].v4l2_scene == ctrl->val) {
-				scene = &scene_configs[i];
-				break;
-			}
-		}
-		if (!scene)
-			return -EINVAL;
-		if (i >= ARRAY_SIZE(scene_configs))
-			return -EINVAL;
-
-		/* Set all the values */
-		dev->scene_mode = ctrl->val;
-
-		if (scene->exposure_mode == MMAL_PARAM_EXPOSUREMODE_OFF)
-			shutter_speed = dev->manual_shutter_speed;
-		else
-			shutter_speed = 0;
-		exposure_mode = scene->exposure_mode;
-		metering_mode = scene->metering_mode;
-
-		v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-			 "%s: scene mode none: shut_speed %d, exp_mode %d, metering %d\n",
-			 __func__, shutter_speed, exposure_mode, metering_mode);
-
-		ret = vchiq_mmal_port_parameter_set(dev->instance, control,
-						    MMAL_PARAMETER_SHUTTER_SPEED,
-						    &shutter_speed,
-						    sizeof(shutter_speed));
-		ret += vchiq_mmal_port_parameter_set(dev->instance, control,
-						     MMAL_PARAMETER_EXPOSURE_MODE,
-						     &exposure_mode,
-						     sizeof(u32));
-		dev->exposure_mode_active = exposure_mode;
-		ret += vchiq_mmal_port_parameter_set(dev->instance, control,
-						     MMAL_PARAMETER_EXPOSURE_MODE,
-						     &exposure_mode,
-						     sizeof(u32));
-		ret += vchiq_mmal_port_parameter_set(dev->instance, control,
-						     MMAL_PARAMETER_EXP_METERING_MODE,
-						     &metering_mode,
-						     sizeof(u32));
-		ret += set_framerate_params(dev);
-	}
-	if (ret) {
-		v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-			 "%s: Setting scene to %d, ret=%d\n",
-			 __func__, ctrl->val, ret);
-		ret = -EINVAL;
-	}
-	return 0;
-}
-
-static int bcm2835_mmal_s_ctrl(struct v4l2_ctrl *ctrl)
-{
-	struct bcm2835_mmal_dev *dev = container_of(ctrl->handler, struct bcm2835_mmal_dev,
-						    ctrl_handler);
-	const struct bcm2835_mmal_v4l2_ctrl *mmal_ctrl = ctrl->priv;
-	int ret;
-
-	if (!mmal_ctrl || mmal_ctrl->id != ctrl->id || !mmal_ctrl->setter) {
-		pr_warn("mmal_ctrl:%p ctrl id:%d\n", mmal_ctrl, ctrl->id);
-		return -EINVAL;
-	}
-
-	ret = mmal_ctrl->setter(dev, ctrl, mmal_ctrl);
-	if (ret)
-		pr_warn("ctrl id:%d/MMAL param %08X- returned ret %d\n",
-			ctrl->id, mmal_ctrl->mmal_id, ret);
-	return ret;
-}
-
-static const struct v4l2_ctrl_ops bcm2835_mmal_ctrl_ops = {
-	.s_ctrl = bcm2835_mmal_s_ctrl,
-};
-
-static const struct bcm2835_mmal_v4l2_ctrl v4l2_ctrls[V4L2_CTRL_COUNT] = {
-	{
-		.id = V4L2_CID_SATURATION,
-		.type = MMAL_CONTROL_TYPE_STD,
-		.min = -100,
-		.max = 100,
-		.def = 0,
-		.step = 1,
-		.imenu = NULL,
-		.mmal_id = MMAL_PARAMETER_SATURATION,
-		.setter = ctrl_set_rational,
-	},
-	{
-		.id = V4L2_CID_SHARPNESS,
-		.type = MMAL_CONTROL_TYPE_STD,
-		.min = -100,
-		.max = 100,
-		.def = 0,
-		.step = 1,
-		.imenu = NULL,
-		.mmal_id = MMAL_PARAMETER_SHARPNESS,
-		.setter = ctrl_set_rational,
-	},
-	{
-		.id = V4L2_CID_CONTRAST,
-		.type = MMAL_CONTROL_TYPE_STD,
-		.min = -100,
-		.max = 100,
-		.def = 0,
-		.step = 1,
-		.imenu = NULL,
-		.mmal_id = MMAL_PARAMETER_CONTRAST,
-		.setter = ctrl_set_rational,
-	},
-	{
-		.id = V4L2_CID_BRIGHTNESS,
-		.type = MMAL_CONTROL_TYPE_STD,
-		.min = 0,
-		.max = 100,
-		.def = 50,
-		.step = 1,
-		.imenu = NULL,
-		.mmal_id = MMAL_PARAMETER_BRIGHTNESS,
-		.setter = ctrl_set_rational,
-	},
-	{
-		.id = V4L2_CID_ISO_SENSITIVITY,
-		.type = MMAL_CONTROL_TYPE_INT_MENU,
-		.min = 0,
-		.max = ARRAY_SIZE(iso_qmenu) - 1,
-		.def = 0,
-		.step = 1,
-		.imenu = iso_qmenu,
-		.mmal_id = MMAL_PARAMETER_ISO,
-		.setter = ctrl_set_iso,
-	},
-	{
-		.id = V4L2_CID_ISO_SENSITIVITY_AUTO,
-		.type = MMAL_CONTROL_TYPE_STD_MENU,
-		.min = 0,
-		.max = V4L2_ISO_SENSITIVITY_AUTO,
-		.def = V4L2_ISO_SENSITIVITY_AUTO,
-		.step = 1,
-		.imenu = NULL,
-		.mmal_id = MMAL_PARAMETER_ISO,
-		.setter = ctrl_set_iso,
-	},
-	{
-		.id = V4L2_CID_IMAGE_STABILIZATION,
-		.type = MMAL_CONTROL_TYPE_STD,
-		.min = 0,
-		.max = 1,
-		.def = 0,
-		.step = 1,
-		.imenu = NULL,
-		.mmal_id = MMAL_PARAMETER_VIDEO_STABILISATION,
-		.setter = ctrl_set_value,
-	},
-	{
-		.id = V4L2_CID_EXPOSURE_AUTO,
-		.type = MMAL_CONTROL_TYPE_STD_MENU,
-		.min = ~0x03,
-		.max = V4L2_EXPOSURE_APERTURE_PRIORITY,
-		.def = V4L2_EXPOSURE_AUTO,
-		.step = 0,
-		.imenu = NULL,
-		.mmal_id = MMAL_PARAMETER_EXPOSURE_MODE,
-		.setter = ctrl_set_exposure,
-	},
-	{
-		.id = V4L2_CID_EXPOSURE_ABSOLUTE,
-		.type = MMAL_CONTROL_TYPE_STD,
-		/* Units of 100usecs */
-		.min = 1,
-		.max = 1 * 1000 * 10,
-		.def = 100 * 10,
-		.step = 1,
-		.imenu = NULL,
-		.mmal_id = MMAL_PARAMETER_SHUTTER_SPEED,
-		.setter = ctrl_set_exposure,
-	},
-	{
-		.id = V4L2_CID_AUTO_EXPOSURE_BIAS,
-		.type = MMAL_CONTROL_TYPE_INT_MENU,
-		.min = 0,
-		.max = ARRAY_SIZE(ev_bias_qmenu) - 1,
-		.def = (ARRAY_SIZE(ev_bias_qmenu) + 1) / 2 - 1,
-		.step = 0,
-		.imenu = ev_bias_qmenu,
-		.mmal_id = MMAL_PARAMETER_EXPOSURE_COMP,
-		.setter = ctrl_set_value_ev,
-	},
-	{
-		.id = V4L2_CID_EXPOSURE_AUTO_PRIORITY,
-		.type = MMAL_CONTROL_TYPE_STD,
-		.min = 0,
-		.max = 1,
-		.def = 0,
-		.step = 1,
-		.imenu = NULL,
-		/* Dummy MMAL ID as it gets mapped into FPS range */
-		.mmal_id = 0,
-		.setter = ctrl_set_exposure,
-	},
-	{
-		.id = V4L2_CID_EXPOSURE_METERING,
-		.type = MMAL_CONTROL_TYPE_STD_MENU,
-		.min = ~0xf,
-		.max = V4L2_EXPOSURE_METERING_MATRIX,
-		.def = V4L2_EXPOSURE_METERING_AVERAGE,
-		.step = 0,
-		.imenu = NULL,
-		.mmal_id = MMAL_PARAMETER_EXP_METERING_MODE,
-		.setter = ctrl_set_metering_mode,
-	},
-	{
-		.id = V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE,
-		.type = MMAL_CONTROL_TYPE_STD_MENU,
-		.min = ~0x3ff,
-		.max = V4L2_WHITE_BALANCE_SHADE,
-		.def = V4L2_WHITE_BALANCE_AUTO,
-		.step = 0,
-		.imenu = NULL,
-		.mmal_id = MMAL_PARAMETER_AWB_MODE,
-		.setter = ctrl_set_awb_mode,
-	},
-	{
-		.id = V4L2_CID_RED_BALANCE,
-		.type = MMAL_CONTROL_TYPE_STD,
-		.min = 1,
-		.max = 7999,
-		.def = 1000,
-		.step = 1,
-		.imenu = NULL,
-		.mmal_id = MMAL_PARAMETER_CUSTOM_AWB_GAINS,
-		.setter = ctrl_set_awb_gains,
-	},
-	{
-		.id = V4L2_CID_BLUE_BALANCE,
-		.type = MMAL_CONTROL_TYPE_STD,
-		.min = 1,
-		.max = 7999,
-		.def = 1000,
-		.step = 1,
-		.imenu = NULL,
-		.mmal_id = MMAL_PARAMETER_CUSTOM_AWB_GAINS,
-		.setter = ctrl_set_awb_gains,
-	},
-	{
-		.id = V4L2_CID_COLORFX,
-		.type = MMAL_CONTROL_TYPE_STD_MENU,
-		.min = 0,
-		.max = V4L2_COLORFX_SET_CBCR,
-		.def = V4L2_COLORFX_NONE,
-		.step = 0,
-		.imenu = NULL,
-		.mmal_id = MMAL_PARAMETER_IMAGE_EFFECT,
-		.setter = ctrl_set_image_effect,
-	},
-	{
-		.id = V4L2_CID_COLORFX_CBCR,
-		.type = MMAL_CONTROL_TYPE_STD,
-		.min = 0,
-		.max = 0xffff,
-		.def = 0x8080,
-		.step = 1,
-		.imenu = NULL,
-		.mmal_id = MMAL_PARAMETER_COLOUR_EFFECT,
-		.setter = ctrl_set_colfx,
-	},
-	{
-		.id = V4L2_CID_ROTATE,
-		.type = MMAL_CONTROL_TYPE_STD,
-		.min = 0,
-		.max = 360,
-		.def = 0,
-		.step = 90,
-		.imenu = NULL,
-		.mmal_id = MMAL_PARAMETER_ROTATION,
-		.setter = ctrl_set_rotate,
-	},
-	{
-		.id = V4L2_CID_HFLIP,
-		.type = MMAL_CONTROL_TYPE_STD,
-		.min = 0,
-		.max = 1,
-		.def = 0,
-		.step = 1,
-		.imenu = NULL,
-		.mmal_id = MMAL_PARAMETER_MIRROR,
-		.setter = ctrl_set_flip,
-	},
-	{
-		.id = V4L2_CID_VFLIP,
-		.type = MMAL_CONTROL_TYPE_STD,
-		.min = 0,
-		.max = 1,
-		.def = 0,
-		.step = 1,
-		.imenu = NULL,
-		.mmal_id = MMAL_PARAMETER_MIRROR,
-		.setter = ctrl_set_flip,
-	},
-	{
-		.id = V4L2_CID_MPEG_VIDEO_BITRATE_MODE,
-		.type = MMAL_CONTROL_TYPE_STD_MENU,
-		.min = 0,
-		.max = V4L2_MPEG_VIDEO_BITRATE_MODE_CBR,
-		.def = 0,
-		.step = 0,
-		.imenu = NULL,
-		.mmal_id = MMAL_PARAMETER_RATECONTROL,
-		.setter = ctrl_set_bitrate_mode,
-	},
-	{
-		.id = V4L2_CID_MPEG_VIDEO_BITRATE,
-		.type = MMAL_CONTROL_TYPE_STD,
-		.min = 25 * 1000,
-		.max = 25 * 1000 * 1000,
-		.def = 10 * 1000 * 1000,
-		.step = 25 * 1000,
-		.imenu = NULL,
-		.mmal_id = MMAL_PARAMETER_VIDEO_BIT_RATE,
-		.setter = ctrl_set_bitrate,
-	},
-	{
-		.id = V4L2_CID_JPEG_COMPRESSION_QUALITY,
-		.type = MMAL_CONTROL_TYPE_STD,
-		.min = 1,
-		.max = 100,
-		.def = 30,
-		.step = 1,
-		.imenu = NULL,
-		.mmal_id = MMAL_PARAMETER_JPEG_Q_FACTOR,
-		.setter = ctrl_set_image_encode_output,
-	},
-	{
-		.id = V4L2_CID_POWER_LINE_FREQUENCY,
-		.type = MMAL_CONTROL_TYPE_STD_MENU,
-		.min = 0,
-		.max = V4L2_CID_POWER_LINE_FREQUENCY_AUTO,
-		.def = 1,
-		.step = 1,
-		.imenu = NULL,
-		.mmal_id = MMAL_PARAMETER_FLICKER_AVOID,
-		.setter = ctrl_set_flicker_avoidance,
-	},
-	{
-		.id = V4L2_CID_MPEG_VIDEO_REPEAT_SEQ_HEADER,
-		.type = MMAL_CONTROL_TYPE_STD,
-		.min = 0,
-		.max = 1,
-		.def = 0,
-		.step = 1,
-		.imenu = NULL,
-		.mmal_id = MMAL_PARAMETER_VIDEO_ENCODE_INLINE_HEADER,
-		.setter = ctrl_set_video_encode_param_output,
-	},
-	{
-		.id = V4L2_CID_MPEG_VIDEO_H264_PROFILE,
-		.type = MMAL_CONTROL_TYPE_STD_MENU,
-		.min = ~(BIT(V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE) |
-			 BIT(V4L2_MPEG_VIDEO_H264_PROFILE_CONSTRAINED_BASELINE) |
-			 BIT(V4L2_MPEG_VIDEO_H264_PROFILE_MAIN) |
-			 BIT(V4L2_MPEG_VIDEO_H264_PROFILE_HIGH)),
-		.max = V4L2_MPEG_VIDEO_H264_PROFILE_HIGH,
-		.def = V4L2_MPEG_VIDEO_H264_PROFILE_HIGH,
-		.step = 1,
-		.imenu = NULL,
-		.mmal_id = MMAL_PARAMETER_PROFILE,
-		.setter = ctrl_set_video_encode_profile_level,
-	},
-	{
-		.id = V4L2_CID_MPEG_VIDEO_H264_LEVEL,
-		.type = MMAL_CONTROL_TYPE_STD_MENU,
-		.min = ~(BIT(V4L2_MPEG_VIDEO_H264_LEVEL_1_0) |
-			 BIT(V4L2_MPEG_VIDEO_H264_LEVEL_1B) |
-			 BIT(V4L2_MPEG_VIDEO_H264_LEVEL_1_1) |
-			 BIT(V4L2_MPEG_VIDEO_H264_LEVEL_1_2) |
-			 BIT(V4L2_MPEG_VIDEO_H264_LEVEL_1_3) |
-			 BIT(V4L2_MPEG_VIDEO_H264_LEVEL_2_0) |
-			 BIT(V4L2_MPEG_VIDEO_H264_LEVEL_2_1) |
-			 BIT(V4L2_MPEG_VIDEO_H264_LEVEL_2_2) |
-			 BIT(V4L2_MPEG_VIDEO_H264_LEVEL_3_0) |
-			 BIT(V4L2_MPEG_VIDEO_H264_LEVEL_3_1) |
-			 BIT(V4L2_MPEG_VIDEO_H264_LEVEL_3_2) |
-			 BIT(V4L2_MPEG_VIDEO_H264_LEVEL_4_0)),
-		.max = V4L2_MPEG_VIDEO_H264_LEVEL_4_0,
-		.def = V4L2_MPEG_VIDEO_H264_LEVEL_4_0,
-		.step = 1,
-		.imenu = NULL,
-		.mmal_id = MMAL_PARAMETER_PROFILE,
-		.setter = ctrl_set_video_encode_profile_level,
-	},
-	{
-		.id = V4L2_CID_SCENE_MODE,
-		.type = MMAL_CONTROL_TYPE_STD_MENU,
-		/* mask is computed at runtime */
-		.min = -1,
-		.max = V4L2_SCENE_MODE_TEXT,
-		.def = V4L2_SCENE_MODE_NONE,
-		.step = 1,
-		.imenu = NULL,
-		.mmal_id = MMAL_PARAMETER_PROFILE,
-		.setter = ctrl_set_scene_mode,
-	},
-	{
-		.id = V4L2_CID_MPEG_VIDEO_H264_I_PERIOD,
-		.type = MMAL_CONTROL_TYPE_STD,
-		.min = 0,
-		.max = 0x7FFFFFFF,
-		.def = 60,
-		.step = 1,
-		.imenu = NULL,
-		.mmal_id = MMAL_PARAMETER_INTRAPERIOD,
-		.setter = ctrl_set_video_encode_param_output,
-	},
-};
-
-int bcm2835_mmal_set_all_camera_controls(struct bcm2835_mmal_dev *dev)
-{
-	int c;
-	int ret = 0;
-
-	for (c = 0; c < V4L2_CTRL_COUNT; c++) {
-		if ((dev->ctrls[c]) && (v4l2_ctrls[c].setter)) {
-			ret = v4l2_ctrls[c].setter(dev, dev->ctrls[c],
-						   &v4l2_ctrls[c]);
-			if (ret) {
-				v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-					 "Failed when setting default values for ctrl %d\n",
-					 c);
-				break;
-			}
-		}
-	}
-	return ret;
-}
-
-int set_framerate_params(struct bcm2835_mmal_dev *dev)
-{
-	struct mmal_parameter_fps_range fps_range;
-	int ret;
-
-	fps_range.fps_high.numerator = dev->capture.timeperframe.denominator;
-	fps_range.fps_high.denominator = dev->capture.timeperframe.numerator;
-
-	if ((dev->exposure_mode_active != MMAL_PARAM_EXPOSUREMODE_OFF) &&
-	    (dev->exp_auto_priority)) {
-		/* Variable FPS. Define min FPS as 1fps. */
-		fps_range.fps_low.numerator = 1;
-		fps_range.fps_low.denominator = 1;
-	} else {
-		/* Fixed FPS - set min and max to be the same */
-		fps_range.fps_low.numerator = fps_range.fps_high.numerator;
-		fps_range.fps_low.denominator = fps_range.fps_high.denominator;
-	}
-
-	v4l2_dbg(1, bcm2835_v4l2_debug, &dev->v4l2_dev,
-		 "Set fps range to %d/%d to %d/%d\n",
-		 fps_range.fps_low.numerator,
-		 fps_range.fps_low.denominator,
-		 fps_range.fps_high.numerator,
-		 fps_range.fps_high.denominator);
-
-	ret = vchiq_mmal_port_parameter_set(dev->instance,
-					    &dev->component[COMP_CAMERA]->output[CAM_PORT_PREVIEW],
-					    MMAL_PARAMETER_FPS_RANGE,
-					    &fps_range, sizeof(fps_range));
-	ret += vchiq_mmal_port_parameter_set(dev->instance,
-					     &dev->component[COMP_CAMERA]->output[CAM_PORT_VIDEO],
-					     MMAL_PARAMETER_FPS_RANGE,
-					     &fps_range, sizeof(fps_range));
-	ret += vchiq_mmal_port_parameter_set(dev->instance,
-					     &dev->component[COMP_CAMERA]->output[CAM_PORT_CAPTURE],
-					     MMAL_PARAMETER_FPS_RANGE,
-					     &fps_range, sizeof(fps_range));
-	if (ret)
-		v4l2_dbg(0, bcm2835_v4l2_debug, &dev->v4l2_dev,
-			 "Failed to set fps ret %d\n", ret);
-
-	return ret;
-}
-
-int bcm2835_mmal_init_controls(struct bcm2835_mmal_dev *dev, struct v4l2_ctrl_handler *hdl)
-{
-	int c;
-	const struct bcm2835_mmal_v4l2_ctrl *ctrl;
-
-	v4l2_ctrl_handler_init(hdl, V4L2_CTRL_COUNT);
-
-	for (c = 0; c < V4L2_CTRL_COUNT; c++) {
-		ctrl = &v4l2_ctrls[c];
-
-		switch (ctrl->type) {
-		case MMAL_CONTROL_TYPE_STD:
-			dev->ctrls[c] = v4l2_ctrl_new_std(hdl, &bcm2835_mmal_ctrl_ops,
-							  ctrl->id, ctrl->min, ctrl->max,
-							  ctrl->step, ctrl->def);
-			break;
-
-		case MMAL_CONTROL_TYPE_STD_MENU:
-		{
-			u64 mask = ctrl->min;
-
-			if (ctrl->id == V4L2_CID_SCENE_MODE) {
-				/* Special handling to work out the mask
-				 * value based on the scene_configs array
-				 * at runtime. Reduces the chance of
-				 * mismatches.
-				 */
-				int i;
-
-				mask = BIT(V4L2_SCENE_MODE_NONE);
-				for (i = 0;
-				     i < ARRAY_SIZE(scene_configs);
-				     i++) {
-					mask |= BIT(scene_configs[i].v4l2_scene);
-				}
-				mask = ~mask;
-			}
-
-			dev->ctrls[c] = v4l2_ctrl_new_std_menu(hdl, &bcm2835_mmal_ctrl_ops,
-							       ctrl->id, ctrl->max, mask,
-							       ctrl->def);
-			break;
-		}
-
-		case MMAL_CONTROL_TYPE_INT_MENU:
-			dev->ctrls[c] = v4l2_ctrl_new_int_menu(hdl, &bcm2835_mmal_ctrl_ops,
-							       ctrl->id, ctrl->max,
-							       ctrl->def, ctrl->imenu);
-			break;
-
-		case MMAL_CONTROL_TYPE_CLUSTER:
-			/* skip this entry when constructing controls */
-			continue;
-		}
-
-		if (hdl->error)
-			break;
-
-		dev->ctrls[c]->priv = (void *)ctrl;
-	}
-
-	if (hdl->error) {
-		pr_err("error adding control %d/%d id 0x%x\n", c,
-		       V4L2_CTRL_COUNT, ctrl->id);
-		return hdl->error;
-	}
-
-	for (c = 0; c < V4L2_CTRL_COUNT; c++) {
-		ctrl = &v4l2_ctrls[c];
-
-		switch (ctrl->type) {
-		case MMAL_CONTROL_TYPE_CLUSTER:
-			v4l2_ctrl_auto_cluster(ctrl->min,
-					       &dev->ctrls[c + 1],
-					       ctrl->max,
-					       ctrl->def);
-			break;
-
-		case MMAL_CONTROL_TYPE_STD:
-		case MMAL_CONTROL_TYPE_STD_MENU:
-		case MMAL_CONTROL_TYPE_INT_MENU:
-			break;
-		}
-	}
-
-	return 0;
-}

-- 
2.50.1


